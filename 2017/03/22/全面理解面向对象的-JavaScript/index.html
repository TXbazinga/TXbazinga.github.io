<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="JavaScript," />





  <link rel="alternate" href="/atom.xml" title="TangXu's Notes" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="来源：DeveloperWorks – 曾滢著

简介： JavaScript 函数式脚本语言特性以及其看似随意的编写风格，导致长期以来人们对这一门语言的误解，即认为 JavaScript 不是一门面向对象的语言，或者只是部分具备一些面向对象的特征。本文将回归面向对象本意，从对语言感悟的角度阐述为什么 JavaScript 是一门彻底的面向对象的语言，以及如何正确地使用这一特性。">
<meta property="og:type" content="article">
<meta property="og:title" content="全面理解面向对象的 JavaScript">
<meta property="og:url" content="http://yoursite.com/2017/03/22/全面理解面向对象的-JavaScript/index.html">
<meta property="og:site_name" content="TangXu's Notes">
<meta property="og:description" content="来源：DeveloperWorks – 曾滢著

简介： JavaScript 函数式脚本语言特性以及其看似随意的编写风格，导致长期以来人们对这一门语言的误解，即认为 JavaScript 不是一门面向对象的语言，或者只是部分具备一些面向对象的特征。本文将回归面向对象本意，从对语言感悟的角度阐述为什么 JavaScript 是一门彻底的面向对象的语言，以及如何正确地使用这一特性。">
<meta property="og:image" content="https://ww4.sinaimg.cn/large/006tNc79ly1fdvi7yfoovj30fy049t9a.jpg">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/006tNc79ly1fdvia3zdbfj30fx0m1q9k.jpg">
<meta property="og:updated_time" content="2017-03-22T04:30:40.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="全面理解面向对象的 JavaScript">
<meta name="twitter:description" content="来源：DeveloperWorks – 曾滢著

简介： JavaScript 函数式脚本语言特性以及其看似随意的编写风格，导致长期以来人们对这一门语言的误解，即认为 JavaScript 不是一门面向对象的语言，或者只是部分具备一些面向对象的特征。本文将回归面向对象本意，从对语言感悟的角度阐述为什么 JavaScript 是一门彻底的面向对象的语言，以及如何正确地使用这一特性。">
<meta name="twitter:image" content="https://ww4.sinaimg.cn/large/006tNc79ly1fdvi7yfoovj30fy049t9a.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/03/22/全面理解面向对象的-JavaScript/"/>





  <title> 全面理解面向对象的 JavaScript | TangXu's Notes </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2a07e8ba78062cbf39ce13182e458a29";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">TangXu's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/22/全面理解面向对象的-JavaScript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tang Xu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TangXu's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                全面理解面向对象的 JavaScript
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-22T11:25:20+08:00">
                2017-03-22
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/22/全面理解面向对象的-JavaScript/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/22/全面理解面向对象的-JavaScript/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>来源：<a href="https://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/index.html" target="_blank" rel="external">DeveloperWorks – 曾滢著</a></p>
<ul>
<li>简介： JavaScript 函数式脚本语言特性以及其看似随意的编写风格，导致长期以来人们对这一门语言的误解，即认为 JavaScript 不是一门面向对象的语言，或者只是部分具备一些面向对象的特征。本文将回归面向对象本意，从对语言感悟的角度阐述为什么 JavaScript 是一门彻底的面向对象的语言，以及如何正确地使用这一特性。</li>
</ul>
<a id="more"></a>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>当今 JavaScript 大行其道，各种应用对其依赖日深。web 程序员已逐渐习惯使用各种优秀的 JavaScript 框架快速开发 Web 应用，从而忽略了对原生 JavaScript 的学习和深入理解。所以，经常出现的情况是，很多做了多年 JS 开发的程序员对闭包、函数式编程、原型总是说不清道不明，即使使用了框架，其代码组织也非常糟糕。这都是对原生 JavaScript 语言特性理解不够的表现。要掌握好 JavaScript，首先一点是必须摒弃一些其他高级语言如 Java、C# 等类式面向对象思维的干扰，全面地从函数式语言的角度理解 JavaScript 原型式面向对象的特点。把握好这一点之后，才有可能进一步使用好这门语言。本文适合群体：使用过 JS 框架但对 JS 语言本质缺乏理解的程序员，具有 Java、C++ 等语言开发经验，准备学习并使用 JavaScript 的程序员，以及一直对 JavaScript 是否面向对象模棱两可，但希望知道真相的 JS 爱好者。</p>
<h3 id="重新认识面向对象"><a href="#重新认识面向对象" class="headerlink" title="重新认识面向对象"></a>重新认识面向对象</h3><p>为了说明 JavaScript 是一门彻底的面向对象的语言，首先有必要从面向对象的概念着手 , 探讨一下面向对象中的几个概念：</p>
<ul>
<li>一切事物皆对象</li>
<li>对象具有封装和继承特性</li>
<li>对象与对象之间使用消息通信，各自存在信息隐藏</li>
</ul>
<p>以这三点做为依据，C++ 是半面向对象半面向过程语言，因为，虽然他实现了类的封装、继承和多态，但存在非对象性质的全局函数和变量。Java、C# 是完全的面向对象语言，它们通过类的形式组织函数和变量，使之不能脱离对象存在。但这里函数本身是一个过程，只是依附在某个类上。</p>
<p>然而，面向对象仅仅是一个概念或者编程思想而已，它不应该依赖于某个语言存在。比如 Java 采用面向对象思想构造其语言，它实现了类、继承、派生、多态、接口等机制。但是这些机制，只是实现面向对象编程的一种手段，而非必须。换言之，一门语言可以根据其自身特性选择合适的方式来实现面向对象。所以，由于大多数程序员首先学习或者使用的是类似 Java、C++ 等高级编译型语言（Java 虽然是半编译半解释，但一般做为编译型来讲解），因而先入为主地接受了“类”这个面向对象实现方式，从而在学习脚本语言的时候，习惯性地用类式面向对象语言中的概念来判断该语言是否是面向对象语言，或者是否具备面向对象特性。这也是阻碍程序员深入学习并掌握 JavaScript 的重要原因之一。</p>
<p>实际上，JavaScript 语言是通过一种叫做 原型（prototype）的方式来实现面向对象编程的。下面就来讨论 基于类的（class-based）面向对象和 基于原型的 (prototype-based) 面向对象这两种方式在构造客观世界的方式上的差别。</p>
<h4 id="基于类的面向对象和基于原型的面向对象方式比较"><a href="#基于类的面向对象和基于原型的面向对象方式比较" class="headerlink" title="基于类的面向对象和基于原型的面向对象方式比较"></a>基于类的面向对象和基于原型的面向对象方式比较</h4><p>在基于类的面向对象方式中，对象（object）依靠 类（class）来产生。而在基于原型的面向对象方式中，对象（object）则是依靠 构造器（constructor）利用 原型（prototype）构造出来的。举个客观世界的例子来说明二种方式认知的差异。例如工厂造一辆车，一方面，工人必须参照一张工程图纸，设计规定这辆车应该如何制造。这里的工程图纸就好比是语言中的 类 (class)，而车就是按照这个 类（class）制造出来的；另一方面，工人和机器 ( 相当于 constructor) 利用各种零部件如发动机，轮胎，方向盘 ( 相当于 prototype 的各个属性 ) 将汽车构造出来。</p>
<p>事实上关于这两种方式谁更为彻底地表达了面向对象的思想，目前尚有争论。但笔者认为原型式面向对象是一种更为彻底的面向对象方式，理由如下：</p>
<p>首先，客观世界中的对象的产生都是其它实物对象构造的结果，而抽象的“图纸”是不能产生“汽车”的，也就是说，类是一个抽象概念而并非实体，而对象的产生是一个实体的产生；</p>
<p>其次，按照一切事物皆对象这个最基本的面向对象的法则来看，类 (class) 本身并不是一个对象，然而原型方式中的构造器 (constructor) 和原型 (prototype) 本身也是其他对象通过原型方式构造出来的对象。</p>
<p>再次，在类式面向对象语言中，对象的状态 (state) 由对象实例 (instance) 所持有，对象的行为方法 (method) 则由声明该对象的类所持有，并且只有对象的结构和方法能够被继承；而在原型式面向对象语言中，对象的行为、状态都属于对象本身，并且能够一起被继承，这也更贴近客观实际。</p>
<p>最后，类式面向对象语言比如 Java，为了弥补无法使用面向过程语言中全局函数和变量的不便，允许在类中声明静态 (static) 属性和静态方法。而实际上，客观世界不存在所谓静态概念，因为一切事物皆对象！而在原型式面向对象语言中，除内建对象 (build-in object) 外，不允许全局对象、方法或者属性的存在，也没有静态概念。所有语言元素 (primitive) 必须依赖对象存在。但由于函数式语言的特点，语言元素所依赖的对象是随着运行时 (runtime) 上下文 (context) 变化而变化的，具体体现在 this 指针的变化。正是这种特点更贴近 “万物皆有所属，宇宙乃万物生存之根本”的自然观点。在 程序清单 1中 window 便类似与宇宙的概念。</p>
<h4 id="清单-1-对象的上下文依赖"><a href="#清单-1-对象的上下文依赖" class="headerlink" title="清单 1. 对象的上下文依赖"></a>清单 1. 对象的上下文依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt; </div><div class="line"> var str = &quot;我是一个 String 对象 , 我声明在这里 , 但我不是独立存在的！&quot;</div><div class="line"> var obj = &#123; des: &quot;我是一个 Object 对象 , 我声明在这里，我也不是独立存在的。&quot; &#125;; </div><div class="line"> var fun = function() &#123; </div><div class="line">    console.log( &quot;我是一个 Function 对象！谁调用我，我属于谁：&quot;, this ); </div><div class="line"> &#125;; </div><div class="line"></div><div class="line"> obj.fun = fun; </div><div class="line"></div><div class="line"> console.log( this === window );     // 打印 true </div><div class="line"> console.log( window.str === str );  // 打印 true </div><div class="line"> console.log( window.obj === obj );  // 打印 true </div><div class="line"> console.log( window.fun === fun );  // 打印 true </div><div class="line"> fun();                              // 打印 我是一个 Function 对象！谁调用我，我属于谁：window </div><div class="line"> obj.fun();                          // 打印 我是一个 Function 对象！谁调用我，我属于谁：obj </div><div class="line"> fun.apply(str);                   // 打印 我是一个 Function 对象！谁调用我，我属于谁：str </div><div class="line"> &lt;/script&gt;</div></pre></td></tr></table></figure>
<p>在接受了面向对象存在一种叫做基于原型实现的方式的事实之后，下面我们就可以来深入探讨 ECMAScript 是如何依据这一方式构造自己的语言的。</p>
<h4 id="最基本的面向对象"><a href="#最基本的面向对象" class="headerlink" title="最基本的面向对象"></a>最基本的面向对象</h4><p>ECMAScript 是一门彻底的面向对象的编程语言（参考资源），JavaScript 是其中的一个变种 (variant)。它提供了 6 种基本数据类型，即 Boolean、Number、String、Null、Undefined、Object。为了实现面向对象，ECMAScript设计出了一种非常成功的数据结构 – JSON(JavaScript Object Notation), 这一经典结构已经可以脱离语言而成为一种广泛应用的数据交互格式 （参考资源）。</p>
<p>应该说，具有基本数据类型和 JSON 构造语法的 ECMAScript 已经基本可以实现面向对象的编程了。开发者可以随意地用 字面式声明（literal notation）方式来构造一个对象，并对其不存在的属性直接赋值，或者用 delete 将属性删除 ( 注：JS 中的 delete 关键字用于删除对象属性，经常被误作为 C++ 中的 delete，而后者是用于释放不再使用的对象 )，如 程序清单 2。</p>
<h4 id="清单-2-字面式-literal-notation-对象声明"><a href="#清单-2-字面式-literal-notation-对象声明" class="headerlink" title="清单 2. 字面式 (literal notation) 对象声明"></a>清单 2. 字面式 (literal notation) 对象声明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var person = &#123; </div><div class="line">    name: “张三”, </div><div class="line">    age: 26, </div><div class="line">    gender: “男”, </div><div class="line">    eat: function( stuff ) &#123; </div><div class="line">        alert( “我在吃” + stuff ); </div><div class="line">    &#125; </div><div class="line"> &#125;; </div><div class="line"> person.height = 176; </div><div class="line"> delete person[ “age” ];</div></pre></td></tr></table></figure>
<p>在实际开发过程中，大部分初学者或者对 JS 应用没有太高要求的开发者也基本上只用到 ECMAScript 定义的这一部分内容，就能满足基本的开发需求。然而，这样的代码复用性非常弱，与其他实现了继承、派生、多态等等的类式面向对象的强类型语言比较起来显得有些干瘪，不能满足复杂的 JS 应用开发。所以 ECMAScript 引入原型来解决对象继承问题。</p>
<h4 id="使用函数构造器构造对象"><a href="#使用函数构造器构造对象" class="headerlink" title="使用函数构造器构造对象"></a>使用函数构造器构造对象</h4><p>除了 字面式声明（literal notation）方式之外，ECMAScript 允许通过 构造器（constructor）创建对象。每个构造器实际上是一个 函数（function） 对象, 该函数对象含有一个“prototype”属性用于实现 基于原型的继承（prototype-based inheritance）和 共享属性（shared properties）。对象可以由“new 关键字 + 构造器调用”的方式来创建，如 程序清单 3：</p>
<h4 id="清单-3-使用构造器-constructor-创建对象"><a href="#清单-3-使用构造器-constructor-创建对象" class="headerlink" title="清单 3. 使用构造器 (constructor) 创建对象"></a>清单 3. 使用构造器 (constructor) 创建对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 构造器 Person 本身是一个函数对象</div><div class="line"> function Person() &#123; </div><div class="line">	 // 此处可做一些初始化工作</div><div class="line"> &#125; </div><div class="line"> // 它有一个名叫 prototype 的属性</div><div class="line"> Person.prototype = &#123; </div><div class="line">    name: “张三”, </div><div class="line">    age: 26, </div><div class="line">    gender: “男”, </div><div class="line">    eat: function( stuff ) &#123; </div><div class="line">        alert( “我在吃” + stuff ); </div><div class="line">    &#125; </div><div class="line"> &#125; </div><div class="line"> // 使用 new 关键字构造对象</div><div class="line"> var p = new Person();</div></pre></td></tr></table></figure>
<p>由于早期 JavaScript 的发明者为了使这门语言与大名鼎鼎的 Java 拉上关系 ( 虽然现在大家知道二者是雷锋和雷锋塔的关系 )，使用了new 关键字来限定构造器调用并创建对象，以使其在语法上跟 Java 创建对象的方式看上去类似。但需要指出的是，这两门语言的new含义毫无关系，因为其对象构造的机理完全不同。也正是因为这里语法上的类似，众多习惯了类式面向对象语言中对象创建方式的程序员，难以透彻理解 JS 对象原型构造的方式，因为他们总是不明白在 JS 语言中，为什么“函数名可以作为类名”的现象。而实质上，JS 这里仅仅是借用了关键字 new，仅此而已；换句话说，ECMAScript 完全可以用其它 非 new 表达式来用调用构造器创建对象。</p>
<h4 id="彻底理解原型链-prototype-chain"><a href="#彻底理解原型链-prototype-chain" class="headerlink" title="彻底理解原型链 (prototype chain)"></a>彻底理解原型链 (prototype chain)</h4><p>在 ECMAScript 中，每个由构造器创建的对象拥有一个指向构造器 prototype 属性值的 隐式引用（implicit reference），这个引用称之为 原型（prototype）。进一步，每个原型可以拥有指向自己原型的 隐式引用（即该原型的原型），如此下去，这就是所谓的原型链（prototype chain） （参考资源）。在具体的语言实现中，每个对象都有一个 <strong> proto </strong> 属性来实现对原型的 隐式引用。程序清单 4说明了这一点。</p>
<h4 id="清单-4-对象的-proto-属性和隐式引用"><a href="#清单-4-对象的-proto-属性和隐式引用" class="headerlink" title="清单 4. 对象的  proto  属性和隐式引用"></a>清单 4. 对象的 <strong> proto </strong> 属性和隐式引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Person( name ) &#123; </div><div class="line">    this.name = name; </div><div class="line"> &#125; </div><div class="line"> var p = new Person(); </div><div class="line"> // 对象的隐式引用指向了构造器的 prototype 属性，所以此处打印 true </div><div class="line"> console.log( p.__proto__ === Person.prototype ); </div><div class="line"></div><div class="line"> // 原型本身是一个 Object 对象，所以他的隐式引用指向了</div><div class="line"> // Object 构造器的 prototype 属性 , 故而打印 true </div><div class="line"> console.log( Person.prototype.__proto__ === Object.prototype ); </div><div class="line"></div><div class="line"> // 构造器 Person 本身是一个函数对象，所以此处打印 true </div><div class="line"> console.log( Person.__proto__ === Function.prototype );</div></pre></td></tr></table></figure>
<p>有了 原型链，便可以定义一种所谓的 属性隐藏机制，并通过这种机制实现继承。ECMAScript 规定，当要给某个对象的属性赋值时，解释器会查找该对象原型链中第一个含有该属性的对象（注：原型本身就是一个对象，那么原型链即为一组对象的链。对象的原型链中的第一个对象是该对象本身）进行赋值。反之，如果要获取某个对象属性的值，解释器自然是返回该对象原型链中首先具有该属性的对象属性值。图 1说名了这中隐藏机制：</p>
<h5 id="图-1-原型链中的属性隐藏机制"><a href="#图-1-原型链中的属性隐藏机制" class="headerlink" title="图 1. 原型链中的属性隐藏机制"></a>图 1. 原型链中的属性隐藏机制</h5><p><img src="https://ww4.sinaimg.cn/large/006tNc79ly1fdvi7yfoovj30fy049t9a.jpg" alt=""></p>
<p>在图 1 中，object1-&gt;prototype1-&gt;prototype2 构成了 对象 object1 的原型链，根据上述属性隐藏机制，可以清楚地看到 prototype1 对象中的 property4 属性和 prototype2 对象中的 property3 属性皆被隐藏。理解了原型链，那么将非常容易理解 JS 中基于原型的继承实现原理，程序清单 5 是利用原型链实现继承的简单例子。</p>
<h4 id="清单-5-利用原型链-Horse-gt-Mammal-gt-Animal-实现继承"><a href="#清单-5-利用原型链-Horse-gt-Mammal-gt-Animal-实现继承" class="headerlink" title="清单 5. 利用原型链 Horse-&gt;Mammal-&gt;Animal 实现继承"></a>清单 5. 利用原型链 Horse-&gt;Mammal-&gt;Animal 实现继承</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">// 声明 Animal 对象构造器</div><div class="line"> function Animal() &#123; </div><div class="line"> &#125; </div><div class="line"> // 将 Animal 的 prototype 属性指向一个对象，</div><div class="line"> // 亦可直接理解为指定 Animal 对象的原型</div><div class="line"> Animal.prototype = &#123; </div><div class="line">    name: &quot;animal&quot;, </div><div class="line">    weight: 0, </div><div class="line">    eat: function() &#123; </div><div class="line">        alert( &quot;Animal is eating!&quot; ); </div><div class="line">    &#125; </div><div class="line"> &#125; </div><div class="line"> // 声明 Mammal 对象构造器</div><div class="line"> function Mammal() &#123; </div><div class="line">    this.name = &quot;mammal&quot;; </div><div class="line"> &#125; </div><div class="line"> // 指定 Mammal 对象的原型为一个 Animal 对象。</div><div class="line"> // 实际上此处便是在创建 Mammal 对象和 Animal 对象之间的原型链</div><div class="line"> Mammal.prototype = new Animal(); </div><div class="line"></div><div class="line"> // 声明 Horse 对象构造器</div><div class="line"> function Horse( height, weight ) &#123; </div><div class="line">    this.name = &quot;horse&quot;; </div><div class="line">    this.height = height; </div><div class="line">    this.weight = weight; </div><div class="line"> &#125; </div><div class="line"> // 将 Horse 对象的原型指定为一个 Mamal 对象，继续构建 Horse 与 Mammal 之间的原型链</div><div class="line"> Horse.prototype = new Mammal(); </div><div class="line"></div><div class="line"> // 重新指定 eat 方法 , 此方法将覆盖从 Animal 原型继承过来的 eat 方法</div><div class="line"> Horse.prototype.eat = function() &#123; </div><div class="line">    alert( &quot;Horse is eating grass!&quot; ); </div><div class="line"> &#125; </div><div class="line"> // 验证并理解原型链</div><div class="line"> var horse = new Horse( 100, 300 ); </div><div class="line"> console.log( horse.__proto__ === Horse.prototype ); </div><div class="line"> console.log( Horse.prototype.__proto__ === Mammal.prototype ); </div><div class="line"> console.log( Mammal.prototype.__proto__ === Animal.prototype );</div></pre></td></tr></table></figure>
<p>理解清单 5 中对象原型继承逻辑实现的关键在于 Horse.prototype = new Mammal() 和 Mammal.prototype = new Animal() 这两句代码。首先，等式右边的结果是构造出一个临时对象，然后将这个对象赋值给等式左边对象的 prototype 属性。也就是说将右边新建的对象作为左边对象的原型。读者可以将这两个等式替换到相应的程序清单 5 代码最后两行的等式中自行领悟。</p>
<h4 id="JavaScript-类式继承的实现方法"><a href="#JavaScript-类式继承的实现方法" class="headerlink" title="JavaScript 类式继承的实现方法"></a>JavaScript 类式继承的实现方法</h4><p>从代码清单 5 可以看出，基于原型的继承方式，虽然实现了代码复用，但其行文松散且不够流畅，可阅读性差，不利于实现扩展和对源代码进行有效地组织管理。不得不承认，类式继承方式在语言实现上更具健壮性，且在构建可复用代码和组织架构程序方面具有明显的优势。这使得程序员们希望寻找到一种能够在 JavaScript 中以类式继承风格进行编码的方法途径。从抽象的角度来讲，既然类式继承和原型继承都是为实现面向对象而设计的，并且他们各自实现的载体语言在计算能力上是等价的 ( 因为图灵机的计算能力与 Lambda 演算的计算能力是等价的 )，那么能不能找到一种变换，使得原型式继承语言通过该变换实现具有类式继承编码的风格呢？</p>
<p>目前一些主流的 JS 框架都提供了这种转换机制，也即类式声明方法，比如 Dojo.declare()、Ext.entend() 等等。用户使用这些框架，可以轻易而友好地组织自己的 JS 代码。其实，在众多框架出现之前，JavaScript 大师 Douglas Crockford 最早利用三个函数对 Function 对象进行扩展，实现了这种变换，关于它的实现细节可以（参考资源）。此外还有由 Dean Edwards实现的著名的 Base.js（参考资源）。值得一提的是，jQuery 之父 John Resig 在搏众家之长之后，用不到 30 行代码便实现了自己的 Simple Inheritance。使用其提供的 extend 方法声明类非常简单。程序清单 6是使用了 Simple Inheritance库实现类的声明的例子。其中最后一句打印输出语句是对 Simple Inheritance实现类式继承的最好说明。</p>
<h4 id="清单-6-使用-Simple-Inheritance-实现类式继承"><a href="#清单-6-使用-Simple-Inheritance-实现类式继承" class="headerlink" title="清单 6. 使用 Simple Inheritance 实现类式继承"></a>清单 6. 使用 Simple Inheritance 实现类式继承</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 声明 Person 类</div><div class="line"> var Person = Class.extend( &#123; </div><div class="line">    _issleeping: true, </div><div class="line">    init: function( name ) &#123; </div><div class="line">        this._name = name; </div><div class="line">    &#125;, </div><div class="line">    isSleeping: function() &#123; </div><div class="line">        return this._issleeping; </div><div class="line">    &#125; </div><div class="line"> &#125; ); </div><div class="line"> // 声明 Programmer 类，并继承 Person </div><div class="line"> var Programmer = Person.extend( &#123; </div><div class="line">    init: function( name, issleeping ) &#123; </div><div class="line">        // 调用父类构造函数</div><div class="line">        this._super( name ); </div><div class="line">        // 设置自己的状态</div><div class="line">        this._issleeping = issleeping; </div><div class="line">    &#125; </div><div class="line"> &#125; ); </div><div class="line"> var person = new Person( &quot;张三&quot; ); </div><div class="line"> var diors = new Programmer( &quot;张江男&quot;, false ); </div><div class="line"> // 打印 true </div><div class="line"> console.log( person.isSleeping() ); </div><div class="line"> // 打印 false </div><div class="line"> console.log( diors.isSleeping() ); </div><div class="line"> // 此处全为 true，故打印 true </div><div class="line"> console.log( person instanceof Person &amp;&amp; person instanceof Class </div><div class="line">    &amp;&amp; diors instanceof Programmer &amp;&amp; </div><div class="line">    diors instanceof Person &amp;&amp; diors instanceof Class );</div></pre></td></tr></table></figure>
<p>如果您已对原型、函数构造器、闭包和基于上下文的 this 有了充分的理解，那么理解 Simple Inheritance 的实现原理也并非相当困难。从本质上讲，var Person = Class.extend(…)该语句中，左边的 Person 实际上是获得了由 Class 调用 extend 方法返回的一个构造器，也即一个 function 对象的引用。顺着这个思路，我们继续介绍 Simple Inheritance 是如何做到这一点，进而实现了由原型继承方式到类式继承方式的转换的。图 2 是 Simple Inheritance 的源码及其附带注释。为了方便理解，用中文对代码逐行补充说明。</p>
<h5 id="图-2-Simple-Inheritance-源码解析"><a href="#图-2-Simple-Inheritance-源码解析" class="headerlink" title="图 2.Simple Inheritance 源码解析"></a>图 2.Simple Inheritance 源码解析</h5><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1fdvia3zdbfj30fx0m1q9k.jpg" alt=""></p>
<p>抛开代码第二部分，整体连贯地考察第一和第三部分会发现，extend 函数的根本目的就是要构造一个具有新原型属性的新构造器。我们不禁感叹 John Resig的大师手笔及其对 JS 语言本质把握的细腻程度。至于 John Resig是如何想到这样精妙的实现方法，感兴趣的读者可以阅读本文 （参考资源），其中有详细介绍关于最初设计 Simple Inheritance 的思维过程。</p>
<h5 id="JavaScript-私有成员实现"><a href="#JavaScript-私有成员实现" class="headerlink" title="JavaScript 私有成员实现"></a>JavaScript 私有成员实现</h5><p>到此为止，如果您任然对 JavaScript 面向对象持怀疑态度，那么这个怀疑一定是，JavaScript 没有实现面向对象中的信息隐藏，即私有和公有。与其他类式面向对象那样显式地声明私有公有成员的方式不同，JavaScript 的信息隐藏就是靠闭包实现的。见 程序清单 7:</p>
<h4 id="清单-7-使用闭包实现信息隐藏"><a href="#清单-7-使用闭包实现信息隐藏" class="headerlink" title="清单 7. 使用闭包实现信息隐藏"></a>清单 7. 使用闭包实现信息隐藏</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 声明 User 构造器</div><div class="line"> function User( pwd ) &#123; </div><div class="line">    // 定义私有属性</div><div class="line">    var password = pwd; </div><div class="line">    // 定义私有方法 </div><div class="line">    function getPassword() &#123; </div><div class="line">        // 返回了闭包中的 password </div><div class="line">        return password; </div><div class="line">    &#125; </div><div class="line">    // 特权函数声明，用于该对象其他公有方法能通过该特权方法访问到私有成员</div><div class="line">    this.passwordService = function() &#123; </div><div class="line">        return getPassword(); </div><div class="line">    &#125; </div><div class="line"> &#125; </div><div class="line"> // 公有成员声明</div><div class="line"> User.prototype.checkPassword = function( pwd ) &#123; </div><div class="line">    return this.passwordService() === pwd; </div><div class="line"> &#125;; </div><div class="line"> // 验证隐藏性</div><div class="line"> var u = new User( &quot;123456&quot; ); </div><div class="line"> // 打印 true </div><div class="line"> console.log( u.checkPassword( &quot;123456&quot; ) ); </div><div class="line"> // 打印 undefined </div><div class="line"> console.log( u.password ); </div><div class="line"> // 打印 true </div><div class="line"> console.log( typeof u.gePassword === &quot;undefined&quot; );</div></pre></td></tr></table></figure>
<p>JavaScript 必须依赖闭包实现信息隐藏，是由其函数式语言特性所决定的。本文不会对函数式语言和闭包这两个话题展开讨论，正如上文默认您理解 JavaScript 中基于上下文的 this 一样。关于 JavaScript 中实现信息隐藏，Douglas Crockford在《 Private members in JavaScript 》（参考资源）一文中有更权威和详细的介绍。</p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>JavaScript 被认为是世界上最受误解的编程语言，因为它身披 c 语言家族的外衣，表现的却是 LISP 风格的函数式语言特性；没有类，却实也彻底实现了面向对象。要对这门语言有透彻的理解，就必须扒开其 c 语言的外衣，从新回到函数式编程的角度，同时摒弃原有类的面向对象概念去学习领悟它。随着近些年来 Web 应用的普及和 JS 语言自身的长足发展，特别是后台 JS 引擎的出现 ( 如基于 V8 的 NodeJS 等 )，可以预见，原来只是作为玩具编写页面效果的 JS 将获得更广阔发展天地。这样的发展趋势，也对 JS 程序员提出了更高要求。只有彻底领悟了这门语言，才有可能在大型的 JS 项目中发挥她的威力。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/17/转-AngularJS开发人员最常犯的10个错误/" rel="next" title="[转]AngularJS开发人员最常犯的10个错误">
                <i class="fa fa-chevron-left"></i> [转]AngularJS开发人员最常犯的10个错误
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/05/31/Vue2-0-组件库总结/" rel="prev" title="Vue2.0+组件库总结">
                Vue2.0+组件库总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
    <section id="comments">
   <!-- 多说评论框 start -->
  <div id="ds-thread" class="ds-thread" data-thread-key="2017/03/22/全面理解面向对象的-JavaScript/" data-title="全面理解面向对象的 JavaScript" data-url="http://yoursite.com/2017/03/22/全面理解面向对象的-JavaScript/" }}"></div>
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <script type="text/javascript">
  var duoshuoQuery = {short_name:"shortTime"};
  (function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
 || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
  <!-- 多说公共JS代码 end -->
  </section>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="Tang Xu" />
          <p class="site-author-name" itemprop="name">Tang Xu</p>
           
              <p class="site-description motion-element" itemprop="description">Keep hungry, Keep foolish!</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重新认识面向对象"><span class="nav-number">2.</span> <span class="nav-text">重新认识面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基于类的面向对象和基于原型的面向对象方式比较"><span class="nav-number">2.1.</span> <span class="nav-text">基于类的面向对象和基于原型的面向对象方式比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#清单-1-对象的上下文依赖"><span class="nav-number">2.2.</span> <span class="nav-text">清单 1. 对象的上下文依赖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最基本的面向对象"><span class="nav-number">2.3.</span> <span class="nav-text">最基本的面向对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#清单-2-字面式-literal-notation-对象声明"><span class="nav-number">2.4.</span> <span class="nav-text">清单 2. 字面式 (literal notation) 对象声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用函数构造器构造对象"><span class="nav-number">2.5.</span> <span class="nav-text">使用函数构造器构造对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#清单-3-使用构造器-constructor-创建对象"><span class="nav-number">2.6.</span> <span class="nav-text">清单 3. 使用构造器 (constructor) 创建对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#彻底理解原型链-prototype-chain"><span class="nav-number">2.7.</span> <span class="nav-text">彻底理解原型链 (prototype chain)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#清单-4-对象的-proto-属性和隐式引用"><span class="nav-number">2.8.</span> <span class="nav-text">清单 4. 对象的  proto  属性和隐式引用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#图-1-原型链中的属性隐藏机制"><span class="nav-number">2.8.1.</span> <span class="nav-text">图 1. 原型链中的属性隐藏机制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#清单-5-利用原型链-Horse-gt-Mammal-gt-Animal-实现继承"><span class="nav-number">2.9.</span> <span class="nav-text">清单 5. 利用原型链 Horse->Mammal->Animal 实现继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JavaScript-类式继承的实现方法"><span class="nav-number">2.10.</span> <span class="nav-text">JavaScript 类式继承的实现方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#清单-6-使用-Simple-Inheritance-实现类式继承"><span class="nav-number">2.11.</span> <span class="nav-text">清单 6. 使用 Simple Inheritance 实现类式继承</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#图-2-Simple-Inheritance-源码解析"><span class="nav-number">2.11.1.</span> <span class="nav-text">图 2.Simple Inheritance 源码解析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JavaScript-私有成员实现"><span class="nav-number">2.11.2.</span> <span class="nav-text">JavaScript 私有成员实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#清单-7-使用闭包实现信息隐藏"><span class="nav-number">2.12.</span> <span class="nav-text">清单 7. 使用闭包实现信息隐藏</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结束语"><span class="nav-number">3.</span> <span class="nav-text">结束语</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tang Xu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"tangxu"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  


  

</body>
</html>
