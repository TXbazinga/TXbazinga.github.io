<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Vue2.0+组件库总结]]></title>
      <url>%2F2017%2F05%2F31%2FVue2-0-%E7%BB%84%E4%BB%B6%E5%BA%93%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[UI组件 element - 饿了么出品的Vue2的web UI工具套件 Vux - 基于Vue和WeUI的组件库 mint-ui - Vue 2的移动UI元素 iview - 基于 Vuejs 的开源 UI 组件库 Keen-UI - 轻量级的基本UI组件合集 vue-material - 通过Vue Material和Vue 2建立精美的app应用 muse-ui - 三端样式一致的响应式 UI 库 vuetify - 为移动而生的Vue JS 2组件框架 vonic - 快速构建移动端单页应用 eme - 优雅的Markdown编辑器 vue-multiselect - Vue.js选择框解决方案 vue-table - 简化数据表格 VueCircleMenu - 漂亮的vue圆环菜单 vue-chat - vuejs和vuex及webpack的聊天示例 radon-ui - 快速开发产品的Vue组件库 vue-waterfall - Vue.js的瀑布布局组件 vue-carbon - 基于 vue 开发MD风格的移动端 vue-beauty - 由vue和ant design创建的优美UI组件 vue-blu - 帮助你轻松创建web应用 vueAdmin - 基于vuejs2和element的简单的管理员模板 vue-syntax-highlight - Sublime Text语法高亮 vue-infinite-scroll - VueJS的无限滚动指令 Vue.Draggable - 实现拖放和视图模型数组同步 vue-awesome-swiper - vue.js触摸滑动组件 vue-calendar - 日期选择插件 bootstrap-vue - 应用于Vuejs2的Twitter的Bootstrap 4组件 vue-swipe - VueJS触摸滑块 vue-amap - 基于Vue 2和高德地图的地图组件 vue-chartjs - vue中的Chartjs的封装 vue-datepicker - 日历和日期选择组件 markcook - 好看的markdown编辑器 vue-google-maps - 带有双向数据绑定Google地图组件 vue-progressbar - vue轻量级进度条 vue-picture-input - 移动友好的图片文件输入组件 vue-infinite-loading - VueJS的无限滚动插件 vue-upload-component - Vuejs文件上传组件 vue-datetime-picker - 日期时间选择控件 vue-scroller - Vonic UI的功能性组件 vue2-calendar - 支持lunar和日期事件的日期选择器 vue-video-player - VueJS视频及直播播放器 vue-fullcalendar - 基于vue.js的全日历组件 rubik - 基于Vuejs2的开源 UI 组件库 VueStar - 带星星动画的vue点赞按钮 vue-mugen-scroll - 无限滚动组件 mint-loadmore - VueJS的双向下拉刷新组件 vue-tables-2 - 显示数据的bootstrap样式网格 vue-virtual-scroller - 带任意数目数据的顺畅的滚动 DataVisualization - 数据可视化 vue-quill-editor - 基于Quill适用于Vue2的富文本编辑器 Vueditor - 所见即所得的编辑器 vue-html5-editor - html5所见即所得编辑器 vue-msgbox - vuejs的消息框 vue-slider - vue 滑动组件 vue-core-image-upload - 轻量级的vue上传插件 vue-slide - vue轻量级滑动组件 vue-lazyload-img - 移动优化的vue图片懒加载插件 vue-drag-and-drop-list - 创建排序列表的Vue指令 vue-progressive-image - Vue的渐进图像加载插件 vuwe - 基于微信WeUI所开发的专用于Vue2的组件库 vue-dropzone - 用于文件上传的Vue组件 vue-charts - 轻松渲染一个图表 vue-swiper - 易于使用的滑块组件 vue-images - 显示一组图片的lightbox组件 vue-carousel-3d - VueJS的3D轮播组件 vue-region-picker - 选择中国的省份市和地区 vue-typer - 模拟用户输入选择和删除文本的Vue组件 vue-impression - 移动Vuejs2 UI元素 vue-datatable - 使用Vuejs创建的DataTableView vue-instant - 轻松创建自动提示的自定义搜索控件 vue-dragging - 使元素可以拖拽 vue-slider-component - 在vue1和vue2中使用滑块 vue2-loading-bar - 最简单的仿Youtube加载条视图 vue-datepicker - 漂亮的Vue日期选择器组件 vue-video - Vue.js的HTML5视频播放器 vue-toast-mobile - VueJS的toast插件 vue-image-crop-upload - vue图片剪裁上传组件 vue-tooltip - 带绑定信息提示的提示工具 vue-highcharts - HighCharts组件 vue-touch-ripple - vuejs的触摸ripple组件 coffeebreak - 实时编辑CSS组件工具 vue-datasource - 创建VueJS动态表格 vue2-timepicker - 下拉时间选择器 vue-date-picker - VueJS日期选择器组件 vue-scrollbar - 最简单的滚动区域组件 vue-quill - vue组件构建quill编辑器 vue-google-signin-button - 导入谷歌登录按钮 vue-svgicon - 创建svg图标组件的工具 vue-float-label - VueJS浮动标签模式 vue-baidu-map - 基于 Vue 2的百度地图组件库 vue-social-sharing - 社交分享组件 vue2-editor - HTML编辑器 vue-tagsinput - 基于VueJS的标签组件 vue-easy-slider - Vue 2.x的滑块组件 datepicker - 基于flatpickr的时间选择组件 vue-chart - 强大的高速的vue图表解析 vue-music-master - vue手机端网页音乐播放器 handsontable - 网页表格组件 vue-simplemde - VueJS的Markdown编辑器组件 vue-popup-mixin - 用于管理弹出框的遮盖层 cubeex - 包含一套完整的移动UI vue-fullcalendar - vue FullCalendar封装 vue-material-design - Vue MD风格组件 vue-morris - Vuejs组件封装Morrisjs库 we-vue - Vue2及weui1开发的组件 vue-image-clip - 基于vue的图像剪辑组件 vue-bootstrap-table - 可排序可检索的表格 vue-radial-progress - Vue.js放射性进度条组件 vue-slick - 实现流畅轮播框的vue组件 vue-pull-to-refresh - Vue2的上拉下拉 vue-form-2 - 全面的HTML表单管理的解决方案 vue-side-nav - 响应式的侧边导航 mint-indicator - VueJS移动加载指示器插件 chartjs - Vue Bulma的chartjs组件 vue-scroll - vue滚动 vue-ripple - 制作谷歌MD风格涟漪效果的Vue组件 vue-touch-keyboard - VueJS虚拟键盘组件 vue-chartkick - VueJS一行代码实现优美图表 vue-ztree - 用 vue 写的树层级组件 vue-m-carousel - vue 移动端轮播组件 vue-datepicker-simple - 基于vue的日期选择器 vue-tabs - 多tab页轻型框架 vue-verify-pop - 带气泡提示的vue校验插件 vue-parallax - 整洁的视觉效果 vue-img-loader - 图片加载UI组件 vue-typewriter - vue组件类型 vue-smoothscroll - smoothscroll的VueJS版本 vue-city - 城市选择器 vue-tree - vue树视图组件 vue-ios-alertview - iOS7+ 风格的alertview服务 dd-vue-component - 订单来了的公共组件库 paco-ui-vue - PACOUI的vue组件 vue-cmap - Vue China map可视化组件 vue-button - Vue按钮组件 开发框架 vue.js - 流行的轻量高效的前端组件化方案 vue-admin - Vue管理面板框架 electron-vue - Electron及VueJS快速启动样板 vue-2.0-boilerplate - Vue2单页应用样板​ vue-spa-template - 前后端分离后的单页应用开发 Framework7-Vue - VueJS与Framework7结合 vue-bulma - 轻量级高性能MVVM Admin UI框架 vue-webgulp - 仿VueJS Vue loader示例 vue-element-starter - vue启动页 实用库 vuex - 专为 Vue.js 应用程序开发的状态管理模式 vuelidate - 简单轻量级的基于模块的Vue.js验证 qingcheng - qingcheng主题 vue-desktop - 创建管理面板网站的UI库 vue-meta - 管理app的meta信息 vue-axios - 将axios整合到VueJS的封装 vue-svg-icon - vue2的可变彩色svg图标方案 avoriaz - VueJS测试实用工具库 vue-framework7 - 结合VueJS使用的Framework7组件 vue-bootstrap-modal - vue的Bootstrap样式组件 vuep - 用实时编辑和预览来渲染Vue组件 vue-online - reactive的在线和离线组件 vue-lazy-render - 用于Vue组件的延迟渲染 vue-password-strength-meter - 交互式密码强度计 element-admin - 支持 vuecli 的 Element UI 的后台模板 vue-electron - 将选择的API封装到Vue对象中的插件 cleave - 基于cleave.js的Cleave组件 vue-events - 简化事件的VueJS插件 vue-shortkey - 应用于Vue.js的Vue-ShortKey 插件 vue-cordova - Cordova的VueJS插件 vue-router-transition - 页面过渡插件 vue-gesture - VueJS的手势事件插件 http-vue-loader - 从html及js环境加载vue文件 vue-qart - 用于qartjs的Vue2指令 vuemit - 处理VueJS事件 vue-websocket - VueJS的Websocket插件 vue-local-storage - 具有类型支持的Vuejs本地储存插件 lazy-vue - 懒加载图片 vue-bus - VueJS的事件总线 vue-reactive-storage - vue插件的Reactive层 vue-notifications - 非阻塞通知库 vue-lazy-component - 懒加载组件或者元素的Vue指令 v-media-query - vue中添加用于配合媒体查询的方法 vue-observe-visibility - 当元素在页面上可见或隐藏时检测 vue-ts-loader - 在Vue装载机检查脚本 vue-pagination-2 - 简单通用的分页组件 vuex-i18n - 定位插件 Vue.resize - 检测HTML调整大小事件的vue指令 vuex-shared-mutations - 分享某种Vuex mutations vue-file-base64 - 将文件转换为Base64的vue组件 modal - Vue Bulma的modal组件 Famous-Vue - Famous库的vue组件 leo-vue-validator - 异步的表单验证组件 Vue-Easy-Validator - 简单的表单验证 vue-truncate-filter - 截断字符串的VueJS过滤器 vue-zoombox - 一个高级zoombox vue-input-autosize - 基于内容自动调整文本输入的大小 vue-lazyloadImg - 图片懒加载插件 服务端 nuxt.js - 用于服务器渲染Vue app的最小化框架 express-vue - 简单的使用服务器端渲染vue.js vue-ssr - 非常简单的VueJS服务器端渲染模板 vue-ssr - 结合Express使用Vue2服务端渲染 vue-easy-renderer - Nodejs服务端渲染 辅助工具 DejaVue - Vuejs可视化及压力测试 vue-play - 展示Vue组件的最小化框架 vscode-VueHelper - 目前vscode最好的vue代码提示插件 vue-generate-component - 轻松生成Vue js组件的CLI工具 vue-multipage-cli - 简单的多页CLI VuejsStarterKit - vuejs starter套件 应用实例 koel - 基于网络的个人音频流媒体服务 pagekit - 轻量级的CMS建站系统 vuedo - 博客平台 jackblog-vue - 个人博客系统 vue-cnode - 重写vue版cnode社区 CMS-of-Blog - 博客内容管理器 rss-reader - 简单的rss阅读器 vue-ghpages-blog - 依赖GitHub Pages无需本地生成的静态博客 swoole-vue-webim - Web版的聊天应用 vue-dashing-js - nuvo-dashing-js的fork fewords - 功能极其简单的笔记本 vue-blog - 使用Vue2.0 和Vuex的vue-blog Demo示例 Vue-cnodejs - 基于vue重写Cnodejs.org的webapp NeteaseCloudWebApp - 高仿网易云音乐的webapp vue-zhihu-daily - 知乎日报 with Vuejs vue-wechat - vue.js开发微信app界面 vue2-demo - 从零构建vue2 + vue-router + vuex 开发环境 eleme - 高仿饿了么app商家详情 vue-demo - vue简易留言板 maizuo - vue/vuex/redux仿卖座网 spa-starter-kit - 单页应用启动套件 vue-music - Vue 音乐搜索播放 douban - 模仿豆瓣前端 vue-Meizi - vue最新实战项目 zhihudaily-vue - 知乎日报web版 vue-demo-kugou - vuejs仿写酷狗音乐webapp VueDemo_Sell_Eleme - Vue2高仿饿了么外卖平台 vue2.0-taopiaopiao - vue2.0与express构建淘票票页面 vue-leancloud-blog - 一个前后端完全分离的单页应用 node-vue-server-webpack - Node.js+Vue.js+webpack快速开发框架 mi-by-vue - VueJS仿小米官网 vue-fis3 - 流行开源工具集成demo vue2.x-douban - Vue2实现简易豆瓣电影webApp vue-demo-maizuo - 使用Vue2全家桶仿制卖座电影 vue-zhihudaily - 知乎日报 Web 版本 vue-adminLte-vue-router - vue和adminLte整合应用 vue-axios-github - 登录拦截登出功能 Zhihu-Daily-Vue.js - Vuejs单页网页应用 hello-vue-django - 使用带有Django的vuejs的样板项目 vue-cnode - vue单页应用demo x-blog - 开源的个人blog项目 vue-express-mongodb - 简单的前后端分离案例 websocket_chat - 基于vue和websocket的多人在线聊天室 photoShare - 基于图片分享的社交平台 vue-zhihudaily-2.0 - 使用Vue2.0+vue-router+vuex创建的zhihudaily notepad - 本地存储的记事本 vueBlog - 前后端分离博客 vue-ruby-china - VueJS框架搭建的rubychina平台 Zhihu_Daily - 基于Vue和Nodejs的Web单页应用 vue-koa-demo - 使用Vue2和Koa1的全栈demo vue2.x-Cnode - 基于vue全家桶的Cnode社区 life-app-vue - 使用vue2完成多功能集合到小webapp github-explorer - 寻找最有趣的GitHub库 vue-trip - vue2做的出行webapp vue-ssr-boilerplate - 精简版的ofvue-hackernews-2 vue-bushishiren - 不是诗人应用 houtai - 基于vue和Element的后台管理系统 ios7-vue - 使用vue2.0 vue-router vuex模拟ios7 Framework7-VueJS - 使用移动框架的示例 cnode-vue - 基于vue和vue-router构建的cnodejs web网站SPA vue-cli-multipage-bootstrap - 将vue官方在线示例整合到组件中 vue-cnode - 用 Vue 做的 CNode 官网 HyaReader - 移动友好的阅读器 zhihu-daily - 轻松查看知乎日报内容 seeMusic - 跨平台云音乐播放器 vue-cnode - 使用cNode社区提供的接口 zhihu-daily-vue - 知乎日报 sls-vuex2-demo - vuex2商城购物车demo vue-dropload - 用以测试下拉加载与简单路由 vue-cnode-mobile - 搭建cnode社区 Vuejs-SalePlatform - vuejs搭建的售卖平台demo v-notes - 简单美观的记事本 vue-starter - VueJs项目的简单启动页 vue-memo - 用 vue写的记事本应用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[全面理解面向对象的 JavaScript]]></title>
      <url>%2F2017%2F03%2F22%2F%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84-JavaScript%2F</url>
      <content type="text"><![CDATA[来源：DeveloperWorks – 曾滢著 简介： JavaScript 函数式脚本语言特性以及其看似随意的编写风格，导致长期以来人们对这一门语言的误解，即认为 JavaScript 不是一门面向对象的语言，或者只是部分具备一些面向对象的特征。本文将回归面向对象本意，从对语言感悟的角度阐述为什么 JavaScript 是一门彻底的面向对象的语言，以及如何正确地使用这一特性。 前言当今 JavaScript 大行其道，各种应用对其依赖日深。web 程序员已逐渐习惯使用各种优秀的 JavaScript 框架快速开发 Web 应用，从而忽略了对原生 JavaScript 的学习和深入理解。所以，经常出现的情况是，很多做了多年 JS 开发的程序员对闭包、函数式编程、原型总是说不清道不明，即使使用了框架，其代码组织也非常糟糕。这都是对原生 JavaScript 语言特性理解不够的表现。要掌握好 JavaScript，首先一点是必须摒弃一些其他高级语言如 Java、C# 等类式面向对象思维的干扰，全面地从函数式语言的角度理解 JavaScript 原型式面向对象的特点。把握好这一点之后，才有可能进一步使用好这门语言。本文适合群体：使用过 JS 框架但对 JS 语言本质缺乏理解的程序员，具有 Java、C++ 等语言开发经验，准备学习并使用 JavaScript 的程序员，以及一直对 JavaScript 是否面向对象模棱两可，但希望知道真相的 JS 爱好者。 重新认识面向对象为了说明 JavaScript 是一门彻底的面向对象的语言，首先有必要从面向对象的概念着手 , 探讨一下面向对象中的几个概念： 一切事物皆对象 对象具有封装和继承特性 对象与对象之间使用消息通信，各自存在信息隐藏 以这三点做为依据，C++ 是半面向对象半面向过程语言，因为，虽然他实现了类的封装、继承和多态，但存在非对象性质的全局函数和变量。Java、C# 是完全的面向对象语言，它们通过类的形式组织函数和变量，使之不能脱离对象存在。但这里函数本身是一个过程，只是依附在某个类上。 然而，面向对象仅仅是一个概念或者编程思想而已，它不应该依赖于某个语言存在。比如 Java 采用面向对象思想构造其语言，它实现了类、继承、派生、多态、接口等机制。但是这些机制，只是实现面向对象编程的一种手段，而非必须。换言之，一门语言可以根据其自身特性选择合适的方式来实现面向对象。所以，由于大多数程序员首先学习或者使用的是类似 Java、C++ 等高级编译型语言（Java 虽然是半编译半解释，但一般做为编译型来讲解），因而先入为主地接受了“类”这个面向对象实现方式，从而在学习脚本语言的时候，习惯性地用类式面向对象语言中的概念来判断该语言是否是面向对象语言，或者是否具备面向对象特性。这也是阻碍程序员深入学习并掌握 JavaScript 的重要原因之一。 实际上，JavaScript 语言是通过一种叫做 原型（prototype）的方式来实现面向对象编程的。下面就来讨论 基于类的（class-based）面向对象和 基于原型的 (prototype-based) 面向对象这两种方式在构造客观世界的方式上的差别。 基于类的面向对象和基于原型的面向对象方式比较在基于类的面向对象方式中，对象（object）依靠 类（class）来产生。而在基于原型的面向对象方式中，对象（object）则是依靠 构造器（constructor）利用 原型（prototype）构造出来的。举个客观世界的例子来说明二种方式认知的差异。例如工厂造一辆车，一方面，工人必须参照一张工程图纸，设计规定这辆车应该如何制造。这里的工程图纸就好比是语言中的 类 (class)，而车就是按照这个 类（class）制造出来的；另一方面，工人和机器 ( 相当于 constructor) 利用各种零部件如发动机，轮胎，方向盘 ( 相当于 prototype 的各个属性 ) 将汽车构造出来。 事实上关于这两种方式谁更为彻底地表达了面向对象的思想，目前尚有争论。但笔者认为原型式面向对象是一种更为彻底的面向对象方式，理由如下： 首先，客观世界中的对象的产生都是其它实物对象构造的结果，而抽象的“图纸”是不能产生“汽车”的，也就是说，类是一个抽象概念而并非实体，而对象的产生是一个实体的产生； 其次，按照一切事物皆对象这个最基本的面向对象的法则来看，类 (class) 本身并不是一个对象，然而原型方式中的构造器 (constructor) 和原型 (prototype) 本身也是其他对象通过原型方式构造出来的对象。 再次，在类式面向对象语言中，对象的状态 (state) 由对象实例 (instance) 所持有，对象的行为方法 (method) 则由声明该对象的类所持有，并且只有对象的结构和方法能够被继承；而在原型式面向对象语言中，对象的行为、状态都属于对象本身，并且能够一起被继承，这也更贴近客观实际。 最后，类式面向对象语言比如 Java，为了弥补无法使用面向过程语言中全局函数和变量的不便，允许在类中声明静态 (static) 属性和静态方法。而实际上，客观世界不存在所谓静态概念，因为一切事物皆对象！而在原型式面向对象语言中，除内建对象 (build-in object) 外，不允许全局对象、方法或者属性的存在，也没有静态概念。所有语言元素 (primitive) 必须依赖对象存在。但由于函数式语言的特点，语言元素所依赖的对象是随着运行时 (runtime) 上下文 (context) 变化而变化的，具体体现在 this 指针的变化。正是这种特点更贴近 “万物皆有所属，宇宙乃万物生存之根本”的自然观点。在 程序清单 1中 window 便类似与宇宙的概念。 清单 1. 对象的上下文依赖1234567891011121314151617&lt;script&gt; var str = &quot;我是一个 String 对象 , 我声明在这里 , 但我不是独立存在的！&quot; var obj = &#123; des: &quot;我是一个 Object 对象 , 我声明在这里，我也不是独立存在的。&quot; &#125;; var fun = function() &#123; console.log( &quot;我是一个 Function 对象！谁调用我，我属于谁：&quot;, this ); &#125;; obj.fun = fun; console.log( this === window ); // 打印 true console.log( window.str === str ); // 打印 true console.log( window.obj === obj ); // 打印 true console.log( window.fun === fun ); // 打印 true fun(); // 打印 我是一个 Function 对象！谁调用我，我属于谁：window obj.fun(); // 打印 我是一个 Function 对象！谁调用我，我属于谁：obj fun.apply(str); // 打印 我是一个 Function 对象！谁调用我，我属于谁：str &lt;/script&gt; 在接受了面向对象存在一种叫做基于原型实现的方式的事实之后，下面我们就可以来深入探讨 ECMAScript 是如何依据这一方式构造自己的语言的。 最基本的面向对象ECMAScript 是一门彻底的面向对象的编程语言（参考资源），JavaScript 是其中的一个变种 (variant)。它提供了 6 种基本数据类型，即 Boolean、Number、String、Null、Undefined、Object。为了实现面向对象，ECMAScript设计出了一种非常成功的数据结构 – JSON(JavaScript Object Notation), 这一经典结构已经可以脱离语言而成为一种广泛应用的数据交互格式 （参考资源）。 应该说，具有基本数据类型和 JSON 构造语法的 ECMAScript 已经基本可以实现面向对象的编程了。开发者可以随意地用 字面式声明（literal notation）方式来构造一个对象，并对其不存在的属性直接赋值，或者用 delete 将属性删除 ( 注：JS 中的 delete 关键字用于删除对象属性，经常被误作为 C++ 中的 delete，而后者是用于释放不再使用的对象 )，如 程序清单 2。 清单 2. 字面式 (literal notation) 对象声明12345678910var person = &#123; name: “张三”, age: 26, gender: “男”, eat: function( stuff ) &#123; alert( “我在吃” + stuff ); &#125; &#125;; person.height = 176; delete person[ “age” ]; 在实际开发过程中，大部分初学者或者对 JS 应用没有太高要求的开发者也基本上只用到 ECMAScript 定义的这一部分内容，就能满足基本的开发需求。然而，这样的代码复用性非常弱，与其他实现了继承、派生、多态等等的类式面向对象的强类型语言比较起来显得有些干瘪，不能满足复杂的 JS 应用开发。所以 ECMAScript 引入原型来解决对象继承问题。 使用函数构造器构造对象除了 字面式声明（literal notation）方式之外，ECMAScript 允许通过 构造器（constructor）创建对象。每个构造器实际上是一个 函数（function） 对象, 该函数对象含有一个“prototype”属性用于实现 基于原型的继承（prototype-based inheritance）和 共享属性（shared properties）。对象可以由“new 关键字 + 构造器调用”的方式来创建，如 程序清单 3： 清单 3. 使用构造器 (constructor) 创建对象123456789101112131415// 构造器 Person 本身是一个函数对象 function Person() &#123; // 此处可做一些初始化工作 &#125; // 它有一个名叫 prototype 的属性 Person.prototype = &#123; name: “张三”, age: 26, gender: “男”, eat: function( stuff ) &#123; alert( “我在吃” + stuff ); &#125; &#125; // 使用 new 关键字构造对象 var p = new Person(); 由于早期 JavaScript 的发明者为了使这门语言与大名鼎鼎的 Java 拉上关系 ( 虽然现在大家知道二者是雷锋和雷锋塔的关系 )，使用了new 关键字来限定构造器调用并创建对象，以使其在语法上跟 Java 创建对象的方式看上去类似。但需要指出的是，这两门语言的new含义毫无关系，因为其对象构造的机理完全不同。也正是因为这里语法上的类似，众多习惯了类式面向对象语言中对象创建方式的程序员，难以透彻理解 JS 对象原型构造的方式，因为他们总是不明白在 JS 语言中，为什么“函数名可以作为类名”的现象。而实质上，JS 这里仅仅是借用了关键字 new，仅此而已；换句话说，ECMAScript 完全可以用其它 非 new 表达式来用调用构造器创建对象。 彻底理解原型链 (prototype chain)在 ECMAScript 中，每个由构造器创建的对象拥有一个指向构造器 prototype 属性值的 隐式引用（implicit reference），这个引用称之为 原型（prototype）。进一步，每个原型可以拥有指向自己原型的 隐式引用（即该原型的原型），如此下去，这就是所谓的原型链（prototype chain） （参考资源）。在具体的语言实现中，每个对象都有一个 proto 属性来实现对原型的 隐式引用。程序清单 4说明了这一点。 清单 4. 对象的 proto 属性和隐式引用12345678910111213function Person( name ) &#123; this.name = name; &#125; var p = new Person(); // 对象的隐式引用指向了构造器的 prototype 属性，所以此处打印 true console.log( p.__proto__ === Person.prototype ); // 原型本身是一个 Object 对象，所以他的隐式引用指向了 // Object 构造器的 prototype 属性 , 故而打印 true console.log( Person.prototype.__proto__ === Object.prototype ); // 构造器 Person 本身是一个函数对象，所以此处打印 true console.log( Person.__proto__ === Function.prototype ); 有了 原型链，便可以定义一种所谓的 属性隐藏机制，并通过这种机制实现继承。ECMAScript 规定，当要给某个对象的属性赋值时，解释器会查找该对象原型链中第一个含有该属性的对象（注：原型本身就是一个对象，那么原型链即为一组对象的链。对象的原型链中的第一个对象是该对象本身）进行赋值。反之，如果要获取某个对象属性的值，解释器自然是返回该对象原型链中首先具有该属性的对象属性值。图 1说名了这中隐藏机制： 图 1. 原型链中的属性隐藏机制 在图 1 中，object1-&gt;prototype1-&gt;prototype2 构成了 对象 object1 的原型链，根据上述属性隐藏机制，可以清楚地看到 prototype1 对象中的 property4 属性和 prototype2 对象中的 property3 属性皆被隐藏。理解了原型链，那么将非常容易理解 JS 中基于原型的继承实现原理，程序清单 5 是利用原型链实现继承的简单例子。 清单 5. 利用原型链 Horse-&gt;Mammal-&gt;Animal 实现继承1234567891011121314151617181920212223242526272829303132333435363738// 声明 Animal 对象构造器 function Animal() &#123; &#125; // 将 Animal 的 prototype 属性指向一个对象， // 亦可直接理解为指定 Animal 对象的原型 Animal.prototype = &#123; name: &quot;animal&quot;, weight: 0, eat: function() &#123; alert( &quot;Animal is eating!&quot; ); &#125; &#125; // 声明 Mammal 对象构造器 function Mammal() &#123; this.name = &quot;mammal&quot;; &#125; // 指定 Mammal 对象的原型为一个 Animal 对象。 // 实际上此处便是在创建 Mammal 对象和 Animal 对象之间的原型链 Mammal.prototype = new Animal(); // 声明 Horse 对象构造器 function Horse( height, weight ) &#123; this.name = &quot;horse&quot;; this.height = height; this.weight = weight; &#125; // 将 Horse 对象的原型指定为一个 Mamal 对象，继续构建 Horse 与 Mammal 之间的原型链 Horse.prototype = new Mammal(); // 重新指定 eat 方法 , 此方法将覆盖从 Animal 原型继承过来的 eat 方法 Horse.prototype.eat = function() &#123; alert( &quot;Horse is eating grass!&quot; ); &#125; // 验证并理解原型链 var horse = new Horse( 100, 300 ); console.log( horse.__proto__ === Horse.prototype ); console.log( Horse.prototype.__proto__ === Mammal.prototype ); console.log( Mammal.prototype.__proto__ === Animal.prototype ); 理解清单 5 中对象原型继承逻辑实现的关键在于 Horse.prototype = new Mammal() 和 Mammal.prototype = new Animal() 这两句代码。首先，等式右边的结果是构造出一个临时对象，然后将这个对象赋值给等式左边对象的 prototype 属性。也就是说将右边新建的对象作为左边对象的原型。读者可以将这两个等式替换到相应的程序清单 5 代码最后两行的等式中自行领悟。 JavaScript 类式继承的实现方法从代码清单 5 可以看出，基于原型的继承方式，虽然实现了代码复用，但其行文松散且不够流畅，可阅读性差，不利于实现扩展和对源代码进行有效地组织管理。不得不承认，类式继承方式在语言实现上更具健壮性，且在构建可复用代码和组织架构程序方面具有明显的优势。这使得程序员们希望寻找到一种能够在 JavaScript 中以类式继承风格进行编码的方法途径。从抽象的角度来讲，既然类式继承和原型继承都是为实现面向对象而设计的，并且他们各自实现的载体语言在计算能力上是等价的 ( 因为图灵机的计算能力与 Lambda 演算的计算能力是等价的 )，那么能不能找到一种变换，使得原型式继承语言通过该变换实现具有类式继承编码的风格呢？ 目前一些主流的 JS 框架都提供了这种转换机制，也即类式声明方法，比如 Dojo.declare()、Ext.entend() 等等。用户使用这些框架，可以轻易而友好地组织自己的 JS 代码。其实，在众多框架出现之前，JavaScript 大师 Douglas Crockford 最早利用三个函数对 Function 对象进行扩展，实现了这种变换，关于它的实现细节可以（参考资源）。此外还有由 Dean Edwards实现的著名的 Base.js（参考资源）。值得一提的是，jQuery 之父 John Resig 在搏众家之长之后，用不到 30 行代码便实现了自己的 Simple Inheritance。使用其提供的 extend 方法声明类非常简单。程序清单 6是使用了 Simple Inheritance库实现类的声明的例子。其中最后一句打印输出语句是对 Simple Inheritance实现类式继承的最好说明。 清单 6. 使用 Simple Inheritance 实现类式继承1234567891011121314151617181920212223242526272829// 声明 Person 类 var Person = Class.extend( &#123; _issleeping: true, init: function( name ) &#123; this._name = name; &#125;, isSleeping: function() &#123; return this._issleeping; &#125; &#125; ); // 声明 Programmer 类，并继承 Person var Programmer = Person.extend( &#123; init: function( name, issleeping ) &#123; // 调用父类构造函数 this._super( name ); // 设置自己的状态 this._issleeping = issleeping; &#125; &#125; ); var person = new Person( &quot;张三&quot; ); var diors = new Programmer( &quot;张江男&quot;, false ); // 打印 true console.log( person.isSleeping() ); // 打印 false console.log( diors.isSleeping() ); // 此处全为 true，故打印 true console.log( person instanceof Person &amp;&amp; person instanceof Class &amp;&amp; diors instanceof Programmer &amp;&amp; diors instanceof Person &amp;&amp; diors instanceof Class ); 如果您已对原型、函数构造器、闭包和基于上下文的 this 有了充分的理解，那么理解 Simple Inheritance 的实现原理也并非相当困难。从本质上讲，var Person = Class.extend(…)该语句中，左边的 Person 实际上是获得了由 Class 调用 extend 方法返回的一个构造器，也即一个 function 对象的引用。顺着这个思路，我们继续介绍 Simple Inheritance 是如何做到这一点，进而实现了由原型继承方式到类式继承方式的转换的。图 2 是 Simple Inheritance 的源码及其附带注释。为了方便理解，用中文对代码逐行补充说明。 图 2.Simple Inheritance 源码解析 抛开代码第二部分，整体连贯地考察第一和第三部分会发现，extend 函数的根本目的就是要构造一个具有新原型属性的新构造器。我们不禁感叹 John Resig的大师手笔及其对 JS 语言本质把握的细腻程度。至于 John Resig是如何想到这样精妙的实现方法，感兴趣的读者可以阅读本文 （参考资源），其中有详细介绍关于最初设计 Simple Inheritance 的思维过程。 JavaScript 私有成员实现到此为止，如果您任然对 JavaScript 面向对象持怀疑态度，那么这个怀疑一定是，JavaScript 没有实现面向对象中的信息隐藏，即私有和公有。与其他类式面向对象那样显式地声明私有公有成员的方式不同，JavaScript 的信息隐藏就是靠闭包实现的。见 程序清单 7: 清单 7. 使用闭包实现信息隐藏1234567891011121314151617181920212223242526// 声明 User 构造器 function User( pwd ) &#123; // 定义私有属性 var password = pwd; // 定义私有方法 function getPassword() &#123; // 返回了闭包中的 password return password; &#125; // 特权函数声明，用于该对象其他公有方法能通过该特权方法访问到私有成员 this.passwordService = function() &#123; return getPassword(); &#125; &#125; // 公有成员声明 User.prototype.checkPassword = function( pwd ) &#123; return this.passwordService() === pwd; &#125;; // 验证隐藏性 var u = new User( &quot;123456&quot; ); // 打印 true console.log( u.checkPassword( &quot;123456&quot; ) ); // 打印 undefined console.log( u.password ); // 打印 true console.log( typeof u.gePassword === &quot;undefined&quot; ); JavaScript 必须依赖闭包实现信息隐藏，是由其函数式语言特性所决定的。本文不会对函数式语言和闭包这两个话题展开讨论，正如上文默认您理解 JavaScript 中基于上下文的 this 一样。关于 JavaScript 中实现信息隐藏，Douglas Crockford在《 Private members in JavaScript 》（参考资源）一文中有更权威和详细的介绍。 结束语JavaScript 被认为是世界上最受误解的编程语言，因为它身披 c 语言家族的外衣，表现的却是 LISP 风格的函数式语言特性；没有类，却实也彻底实现了面向对象。要对这门语言有透彻的理解，就必须扒开其 c 语言的外衣，从新回到函数式编程的角度，同时摒弃原有类的面向对象概念去学习领悟它。随着近些年来 Web 应用的普及和 JS 语言自身的长足发展，特别是后台 JS 引擎的出现 ( 如基于 V8 的 NodeJS 等 )，可以预见，原来只是作为玩具编写页面效果的 JS 将获得更广阔发展天地。这样的发展趋势，也对 JS 程序员提出了更高要求。只有彻底领悟了这门语言，才有可能在大型的 JS 项目中发挥她的威力。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]AngularJS开发人员最常犯的10个错误]]></title>
      <url>%2F2017%2F03%2F17%2F%E8%BD%AC-AngularJS%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E6%9C%80%E5%B8%B8%E7%8A%AF%E7%9A%8410%E4%B8%AA%E9%94%99%E8%AF%AF%2F</url>
      <content type="text"><![CDATA[转自：[伯乐在线]http://blog.jobbole.com/78946/简介AngularJS是目前最为活跃的JavaScript框架之一，AngularJS的目标之一是简化开发过程，这使得AngularJS非常善于构建小型app原型，但AngularJS对于全功能的客户端应用程序同样强大，它结合了开发简便，特性广泛和出众的性能，使其被广泛使用。然而，大量使用也会产生诸多误区。以下这份列表摘取了常见的一些AngularJS的错误用法，尤其是在app开发过程中。 1. MVC目录结构AngularJS，直白地说，就是一个MVC框架。它的模型并没有像backbone.js框架那样定义的如此明确，但它的体系结构却恰如其分。当你工作于一个MVC框架时，普遍的做法是根据文件类型对其进行归类： 123456789101112131415templates/ _login.html _feed.htmlapp/ app.js controllers/ LoginController.js FeedController.js directives/ FeedEntryDirective.js services/ LoginService.js FeedService.js filters/ CapatalizeFilter.js 看起来，这似乎是一个显而易见的结构，更何况Rails也是这么干的。然而一旦app规模开始扩张，这种结构会导致你一次需要打开很多目录，无论你是使用sublime，Visual Studio或是Vim结合Nerd Tree，你都会投入很多时间在目录树中不断地滑上滑下。 与按照类型划分文件不同，取而代之的，我们可以按照特性划分文件： 12345678910111213app/ app.js Feed/ _feed.html FeedController.js FeedEntryDirective.js FeedService.js Login/ _login.html LoginController.js LoginService.js Shared/ CapatalizeFilter.js 这种目录结构使得我们能够更容易地找到与某个特性相关的所有文件，继而加快我们的开发进度。尽管将.html和.js文件置于一处可能存在争议，但节省下来的时间更有价值。 2. 模块将所有东西都一股脑放在主模块下是很常见的，对于小型app，刚开始并没有什么问题，然而很快你就会发现坑爹的事来了。 1234567var app = angular.module(&apos;app&apos;,[]);app.service(&apos;MyService&apos;, function()&#123; //service code&#125;);app.controller(&apos;MyCtrl&apos;, function($scope, MyService)&#123; //controller code&#125;); 在此之后，一个常见的策略是对相同类型的对象归类。 1234567891011var services = angular.module(&apos;services&apos;,[]);services.service(&apos;MyService&apos;, function()&#123; //service code&#125;); var controllers = angular.module(&apos;controllers&apos;,[&apos;services&apos;]);controllers.controller(&apos;MyCtrl&apos;, function($scope, MyService)&#123; //controller code&#125;); var app = angular.module(&apos;app&apos;,[&apos;controllers&apos;, &apos;services&apos;]); 这种方式和前面第一部分所谈到的目录结构差不多：不够好。根据相同的理念，可以按照特性归类，这会带来可扩展性。 12345678var sharedServicesModule = angular.module(&apos;sharedServices&apos;,[]);sharedServices.service(&apos;NetworkService&apos;, function($http)&#123;&#125;); var loginModule = angular.module(&apos;login&apos;,[&apos;sharedServices&apos;]);loginModule.service(&apos;loginService&apos;, function(NetworkService)&#123;&#125;);loginModule.controller(&apos;loginCtrl&apos;, function($scope, loginService)&#123;&#125;); var app = angular.module(&apos;app&apos;, [&apos;sharedServices&apos;, &apos;login&apos;]); 当我们开发一个大型应用程序时，可能并不是所有东西都包含在一个页面上。将同一类特性置于一个模块内，能使跨app间重用模块变得更容易。 3. 依赖注入依赖注入是AngularJS最好的模式之一，它使得测试更为简单，并且依赖任何指定对象都很明确。AngularJS的注入方式非常灵活，最简单的方式只需要将依赖的名字传入模块的function中即可： 1234567var app = angular.module(&apos;app&apos;,[]); app.controller(&apos;MainCtrl&apos;, function($scope, $timeout)&#123; $timeout(function()&#123; console.log($scope); &#125;, 1000);&#125;); 这里，很明显，MainCtrl依赖$scope和$timeout。 直到你准备将其部署到生产环境并希望精简代码时，一切都很美好。如果使用UglifyJS，之前的例子会变成下面这样： 12var app=angular.module(&quot;app&quot;,[]);app.controller(&quot;MainCtrl&quot;,function(e,t)&#123;t(function()&#123;console.log(e)&#125;,1e3)&#125;) 现在AngularJS怎么知道MainCtrl依赖谁？AngularJS提供了一种非常简单的解决方法，即将依赖作为一个数组传入，数组的最后一个元素是一个函数，所有的依赖项作为它的参数。 12345app.controller(&apos;MainCtrl&apos;, [&apos;$scope&apos;, &apos;$timeout&apos;, function($scope, $timeout)&#123; $timeout(function()&#123; console.log($scope); &#125;, 1000);&#125;]); 这样做能够精简代码，并且AngularJS知道如何解释这些明确的依赖： 1app.controller(&quot;MainCtrl&quot;,[&quot;$scope&quot;,&quot;$timeout&quot;,function(e,t)&#123;t(function()&#123;console.log(e)&#125;,1e3)&#125;]) 3.1 全局依赖在编写AngularJS程序时，时常会出现这种情况：某个对象有一个依赖，而这个对象又将其自身绑定在全局scope上，这意味着在任何AngularJS代码中这个依赖都是可用的，但这却破坏了依赖注入模型，并会导致一些问题，尤其体现在测试过程中。 使用AngularJS可以很容易的将这些全局依赖封装进模块中，所以它们可以像AngularJS标准模块那样被注入进去。 Underscrore.js是一个很赞的库，它可以以函数式的风格简化Javascript代码，通过以下方式，你可以将其转化为一个模块： 12345678910111213var underscore = angular.module(&apos;underscore&apos;, []);underscore.factory(&apos;_&apos;, function() &#123; return window._; //Underscore must already be loaded on the page&#125;);var app = angular.module(&apos;app&apos;, [&apos;underscore&apos;]);app.controller(&apos;MainCtrl&apos;, [&apos;$scope&apos;, &apos;_&apos;, function($scope, _) &#123; init = function() &#123; _.keys($scope); &#125; init();&#125;]); 这样的做法允许应用程序继续以AngularJS依赖注入的风格进行开发，同时在测试阶段也能将underscore交换出去。 这可能看上去十分琐碎，没什么必要，但如果你的代码中正在使用use strict（而且必须使用），那这就是必要的了。 4. 控制器膨胀控制器是AngularJS的肉和土豆，一不小心就会将过多的逻辑加入其中，尤其是刚开始的时候。控制器永远都不应该去操作DOM，或是持有DOM选择器，那是我们需要使用指令和ng-model的地方。同样的，业务逻辑应该存在于服务中，而非控制器。 数据也应该存储在服务中，除非它们已经被绑定在$scope上了。服务本身是单例的，在应用程序的整个生命周期都存在，然而控制器在应用程序的各状态间是瞬态的。如果数据被保存在控制器中，当它被再次实例化时就需要重新从某处获取数据。即使将数据存储于localStorage中，检索的速度也要比Javascript变量慢一个数量级。 AngularJS在遵循单一职责原则（SRP）时运行良好，如果控制器是视图和模型间的协调者，那么它所包含的逻辑就应该尽量少，这同样会给测试带来便利。 5. Service vs Factory几乎每一个AngularJS开发人员在初学时都会被这些名词所困扰，这真的不太应该，因为它们就是针对几乎相同事物的语法糖而已！ 以下是它们在AngularJS源代码中的定义： 123456789function factory(name, factoryFn) &#123; return provider(name, &#123; $get: factoryFn &#125;); &#125;function service(name, constructor) &#123; return factory(name, [&apos;$injector&apos;, function($injector) &#123; return $injector.instantiate(constructor); &#125;]);&#125; 从源代码中你可以看到，service仅仅是调用了factory函数，而后者又调用了provider函数。事实上，AngularJS也为一些值、常量和装饰提供额外的provider封装，而这些并没有导致类似的困惑，它们的文档都非常清晰。 由于service仅仅是调用了factory函数，这有什么区别呢？线索在$injector.instantiate：在这个函数中，$injector在service的构造函数中创建了一个新的实例。 以下是一个例子，展示了一个service和一个factory如何完成相同的事情： 123456789101112131415var app = angular.module(&apos;app&apos;,[]);app.service(&apos;helloWorldService&apos;, function()&#123; this.hello = function() &#123; return &quot;Hello World&quot;; &#125;;&#125;);app.factory(&apos;helloWorldFactory&apos;, function()&#123; return &#123; hello: function() &#123; return &quot;Hello World&quot;; &#125; &#125;&#125;); 当helloWorldService或helloWorldFactory被注入到控制器中，它们都有一个hello方法，返回”hello world”。service的构造函数在声明时被实例化了一次，同时factory对象在每一次被注入时传递，但是仍然只有一个factory实例。所有的providers都是单例。 既然能做相同的事，为什么需要两种不同的风格呢？相对于service，factory提供了更多的灵活性，因为它可以返回函数，这些函数之后可以被新建出来。这迎合了面向对象编程中工厂模式的概念，工厂可以是一个能够创建其他对象的对象。 123456789app.factory(&apos;helloFactory&apos;, function() &#123; return function(name) &#123; this.name = name; this.hello = function() &#123; return &quot;Hello &quot; + this.name; &#125;; &#125;;&#125;); 这里是一个控制器示例，使用了service和两个factory，helloFactory返回了一个函数，当新建对象时会设置name的值。 123456789app.controller(&apos;helloCtrl&apos;, function($scope, helloWorldService, helloWorldFactory, helloFactory) &#123; init = function() &#123; helloWorldService.hello(); //&apos;Hello World&apos; helloWorldFactory.hello(); //&apos;Hello World&apos; new helloFactory(&apos;Readers&apos;).hello() //&apos;Hello Readers&apos; &#125; init();&#125;); 在初学时，最好只使用service。 Factory在设计一个包含很多私有方法的类时也很有用： 1234567891011app.factory(&apos;privateFactory&apos;, function()&#123; var privateFunc = function(name) &#123; return name.split(&quot;&quot;).reverse().join(&quot;&quot;); //reverses the name &#125;; return &#123; hello: function(name)&#123; return &quot;Hello &quot; + privateFunc(name); &#125; &#125;;&#125;); 通过这个例子，我们可以让privateFactory的公有API无法访问到privateFunc方法，这种模式在service中是可以做到的，但在factory中更容易。 6. 没有使用BatarangBatarang是一个出色的Chrome插件，用来开发和测试AngularJS app。 Batarang提供了浏览模型的能力，这使得我们有能力观察AngularJS内部是如何确定绑定到作用域上的模型的，这在处理指令以及隔离一定范围观察绑定值时非常有用。 Batarang也提供了一个依赖图， 如果我们正在接触一个未经测试的代码库，这个依赖图就很有用，它能决定哪些服务应该被重点关照。 最后，Batarang提供了性能分析。Angular能做到开包即用，性能良好，然而对于一个充满了自定义指令和复杂逻辑的应用而言，有时候就不那么流畅了。使用Batarang性能工具，能够直接观察到在一个digest周期中哪个函数运行了最长时间。性能工具也能展示一棵完整的watch树，在我们拥有很多watcher时，这很有用。 7. 过多的watcher在上一点中我们提到，AngularJS能做到开包即用，性能良好。由于需要在一个digest周期中完成脏数据检查，一旦watcher的数量增长到大约2000时，这个周期就会产生显著的性能问题。（2000这个数字不能说一定会造成性能大幅下降，但这是一个不错的经验数值。在AngularJS 1.3 release版本中，已经有一些允许严格控制digest周期的改动了，Aaron Gray有一篇很好的文章对此进行解释。） 以下这个“立即执行的函数表达式(IIFE)”会打印出当前页面上所有的watcher的个数，你可以简单的将其粘贴到控制台中，观察结果。这段IIFE来源于Jared在StackOverflow上的回答： 1234567891011121314151617181920(function () &#123; var root = $(document.getElementsByTagName(&apos;body&apos;)); var watchers = []; var f = function (element) &#123; if (element.data().hasOwnProperty(&apos;$scope&apos;)) &#123; angular.forEach(element.data().$scope.$$watchers, function (watcher) &#123; watchers.push(watcher); &#125;); &#125; angular.forEach(element.children(), function (childElement) &#123; f($(childElement)); &#125;); &#125;; f(root); console.log(watchers.length);&#125;)(); 通过这个方式得到watcher的数量，结合Batarang性能板块中的watch树，应该可以看到哪里存在重复代码，或着哪里存在不变数据同时拥有watch。 当存在不变数据，而你又想用AngularJS将其模版化，可以考虑使用bindonce。Bindonce是一个简单的指令，允许你使用AngularJS中的模版，但它并不会加入watch，这就保证了watch数量不会增长。 8. 限定$scope的范围Javascript基于原型的继承与面向对象中基于类的继承有着微妙的区别，这通常不是什么问题，但这个微妙之处在使用$scope时就会表现出来。在AngularJS中，每个$scope都会继承父$scope，最高层称之为$rootScope。（$scope与传统指令有些不同，它们有一定的作用范围i，且只继承显式声明的属性。） 由于原型继承的特点，在父类和子类间共享数据不太重要，不过如果不小心的话，也很容易误用了一个父$scope的属性。 比如说，我们需要在一个导航栏上显示一个用户名，这个用户名是在登录表单中输入的，下面这种尝试应该是能工作的： 1234567&lt;div ng-controller=&quot;navCtrl&quot;&gt; &lt;span&gt;&#123;&#123;user&#125;&#125;&lt;/span&gt; &lt;div ng-controller=&quot;loginCtrl&quot;&gt; &lt;span&gt;&#123;&#123;user&#125;&#125;&lt;/span&gt; &lt;input ng-model=&quot;user&quot;&gt;&lt;/input&gt; &lt;/div&gt;&lt;/div&gt; 那么问题来了……：在text input中设置了user的ng-model，当用户在其中输入内容时，哪个模版会被更新？navCtrl还是loginCtrl，还是都会？ 如果你选择了loginCtrl，那么你可能已经理解了原型继承是如何工作的了。 当你检索字面值时，原型链并不起作用。如果navCtrl也同时被更新的话，检索原型链是必须的；但如果值是一个对象，这就会发生。（记住，在Javascript中，函数、数组和对象都是对象） 所以为了获得预期的行为，需要在navCtrl中创建一个对象，它可以被loginCtrl引用。 1234567&lt;div ng-controller=&quot;navCtrl&quot;&gt; &lt;span&gt;&#123;&#123;user.name&#125;&#125;&lt;/span&gt; &lt;div ng-controller=&quot;loginCtrl&quot;&gt; &lt;span&gt;&#123;&#123;user.name&#125;&#125;&lt;/span&gt; &lt;input ng-model=&quot;user.name&quot;&gt;&lt;/input&gt; &lt;/div&gt;&lt;/div&gt; 现在，由于user是一个对象，原型链就会起作用，navCtrl模版和$scope和loginCtrl都会被更新。 这看上去是一个很做作的例子，但是当你使用某些指令去创建子$scope，如ngRepeat时，这个问题很容易就会产生。 9. 手工测试由于TDD可能不是每个开发人员都喜欢的开发方式，因此当开发人员检查代码是否工作或是否影响了其它东西时，他们会做手工测试。 不去测试AngularJS app，这是没有道理的。AngularJS的设计使得它从头到底都是可测试的，依赖注入和ngMock模块就是明证。AngularJS核心团队已经开发了众多能够使测试更上一层楼的工具。 9.1 Protractor单元测试是一个测试工作的基础，但考虑到app的日益复杂，集成测试更贴近实际情况。幸运的是，AngularJS的核心团队已经提供了必要的工具。 我们已经建立了Protractor，一个端到端的测试器用以模拟用户交互，这能够帮助你验证你的AngularJS程序的健康状况。 Protractor使用Jasmine测试框架定义测试，Protractor针对不同的页面交互行为有一个非常健壮的API。 我们还有一些其他的端到端测试工具，但是Protractor的优势是它能够理解如何与AngularJS代码协同工作，尤其是在$digest周期中。 9.2 Karma一旦我们用Protractor完成了集成测试的编写工作，接下去就是执行测试了。等待测试执行，尤其是集成测试，对每个开发人员都是一种淡淡的忧伤。AngularJS的核心团队也感到极为蛋疼，于是他们开发了Karma。 Karma是一个测试器，它有助于关闭反馈回路。Karma之所以能够做到这点，是因为它在指定文件被改变时就运行测试。Karma同时也会在多个浏览器上运行测试，不同的设备也可以指向Karma服务器，这样就能够更好地覆盖真实世界的应用场景。 10. 使用jQueryjQuery是一个酷炫的库，它有标准化的跨平台开发，几乎已经成为了现代化Web开发的必需品。不过尽管JQuery如此多的优秀特性，它的理念和AngularJS并不一致。 AngularJS是一个用来建立app的框架，而JQuery则是一个简化“HTML文档操作、事件处理、动画和Ajax”的库。这是两者最基本的区别，AngularJS致力于程序的体系结构，与HTML页面无关。 为了更好的理解如何建立一个AngularJS程序，请停止使用jQuery。JQuery使开发人员以现存的HTML标准思考问题，但正如文档里所说的，“AngularJS能够让你在应用程序中扩张HTML这个词汇”。 DOM操作应该只在指令中完成，但这并不意味着他们只能用JQuery封装。在你使用JQuery之前，你应该总是去想一下这个功能是不是AngularJS已经提供了。当指令互相依赖时能够创建强大的工具，这确实很强大。 但一个非常棒的JQuery是必需品时，这一天可能会到来，但在一开始就引入它，是一个常见的错误。 结论AngularJS是一卓越的框架，在社区的帮助下始终在进步。虽说AngularJS仍然是一个不断发展的概念，但我希望人们能够遵循以上谈到的这些约定，避免开发AngularJS应用所遇到的那些问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React生命周期]]></title>
      <url>%2F2017%2F03%2F15%2FReact%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
      <content type="text"><![CDATA[React组件的生命周期创建期(五个阶段)1.getDefaultProps(获取默认属性) 作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享。 2.getInitialState (获取默认状态) 作用于组件的实例，在实例创建时调用一次，用于初始化每个实例的state，此时可以访问this.props。 3.componentWillMount (组件将要构建) 在完成首次渲染之前调用，此时仍可以修改组件的state。4.render (组件渲染输出虚拟dom) 必选的方法，创建虚拟DOM，该方法具有特殊的规则: 只能通过this.props和this.state访问数据 可以返回null、false或任何React组件 只能出现一个顶级组件（不能返回数组） 不能改变组件的状态 * 不能修改DOM的输出 5.componentDidMount(组件渲染完成) 真实的DOM被渲染出来后调用，在该方法中可通过this.getDOMNode()(也可以ReactDOM.findDOMNode(this))访问到真实的DOM元素。此时已可以使用其他类库来操作这个DOM。（在服务端中，该方法不会被调用） 存在期 (五个阶段)1.componentWillReceiveProps(接受新的属性) 组件接收到新的props时调用，并将其作为参数nextProps使用，此时可以更改组件props及state。 componentWillReceiveProps: function(nextProps) { if (nextProps.bool) { this.setState({ bool: true }); } } 2.shouldComponentUpdate(组建是否应该更新) **必须有返回值(return false/true) 第一个参数是新属性 第二个参数是新状态 组件是否应当渲染新的props或state，返回false表示跳过后续的生命周期方法，通常不需要使用以避免出现bug。在出现应用的瓶颈时，可通过该方法进行适当的优化。 3.componentWillUpdate (组件将要被更新) 第一个参数是新属性第二个参数是新状态 接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state。 4.render(组件更新输出dom) 没有参数 这个阶段访问的都是旧的虚拟dom 只有之后的一个阶段访问的才是新的虚拟dom 5.componentDidUpdate(组件更新完成) 完成渲染新的props或者state后调用，此时可以访问到新的DOM元素。 销毁期 componentWillUnmount组件被移除之前被调用，可以用于做一些清理工作，在componentDidMount方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack15个知识点!]]></title>
      <url>%2F2017%2F03%2F13%2Fwebpack%2F</url>
      <content type="text"><![CDATA[一、模块化系统演进：1、传统：&lt;script src=“module.js”&gt;标签； 2、commonJS：协同require（）同步加载，再通过exports或module.exports来导出需要暴露的接口；不能加载多个模块；不适合浏览器加载。 3、AMD:异步require，通过接口define（） 异步加载；可并行加载多个模块；适合浏览器。 4、CMD:类似AMD； 5、UMD:是模块跨平台解决方案； 6、ES6:尽量静态化；编译时就能确定模块的依赖关系及输入输出变量；CommonJs和AMD都只能在运行时确定这些东西。优点：静态分析，提前编译；面向未来的标准；缺点：1、浏览器原生兼容性差，所以一般都编译成ES5。2、目前可以拿来即用的模块少，生态差。 7、期望的模块：可以兼容多种模块风格，尽量可以利用已有的代码，不仅仅只是 JavaScript 模块化，还有 CSS、图片、字体等资源也需要模块化。 二、gulp&amp;webpack区别：gulp是基于流的构建工具：all in one的打包模式，输出一个js文件和一个css文件，优点是减少http请求，万金油方案。webpack是模块化管理工具，使用webpack可以对模块进行压缩、预处理、打包、按需加载等。 三、webpack概念：webpack是模块化管理工具，使用webpack可以对模块进行压缩、预处理、按需打包、按需加载等。 四、webpack9个特征：（1）插件化：webpack本身非常灵活，提供了丰富的插件接口。基于这些接口，webpack开发了很多插件作为内置功能。（2）速度快：webpack使用异步IO以及多级缓存机制。所以webpack的速度是很快的，尤其是增量更新。（3）丰富的Loaders：loaders用来对文件做预处理。这样webpack就可以打包任何静态文件。（4）高适配性：webpack同时支持AMD/CommonJs/ES6模块方案。webpack会静态解析你的代码，自动帮你管理他们的依赖关系。此外，webpack对第三方库的兼容性很好。（5）代码拆分：webpack可以将你的代码分片，从而实现按需打包。这种机制可以保证页面只加载需要的JS代码，减少首次请求的时间。（6）优化：webpack提供了很多优化机制来减少打包输出的文件大小，不仅如此，它还提供了hash机制，来解决浏览器缓存问题。（7）开发模式友好：webpack为开发模式也提供了很多辅助功能。比如SourceMap、热更新等。（8）使用场景多：webpack不仅适用于web应用场景，也适用于Webworkers、Node.js场景。（9）优点：webpack并不强制你使用某种模块化方案，而是通过兼容所有模块化方案让你无痛接入项目，当然这也是webpack牛逼的地方。有了webpack，你可以随意选择你喜欢的模块化方案，至于怎么处理模块之间的依赖关系及如何按需打包，放轻松，webpack会帮你处理好的。 五、webpack配置及参数解析：1、两份配置文件webpack.config.production.js/webpack.config.development.js，然后不同场景下，使用不同的配置文件。2、通过module.exports返回函数，该函数能接受参数。相对来说，第一种更简单，但是重复配置多；第二种更灵活，推荐第二种方式。 webpack 如何最佳配置？webpack官方提供的配置方法是通过module.exports返回一个json，但是这种场景不灵活，不能适配多种场景。比如要解决：production模式和development模式，webpack的配置是有差异的，大致有两种思路。1、两份配置文件webpack.config.production.js/webpack.config.development.js，然后不同场景下，使用不同的配置文件。2、通过module.exports返回函数，该函数能接受参数。相对来说，第一种更简单，但是重复配置多；第二种更灵活，推荐第二种方式。那么，按返回函数的方式的配置代码架子如下： module.exports = function(env) { return { context: config.context, entry: config.src, output: { path: path.join(config.jsDest, project), filename: &apos;[name].js&apos;, chunkFilename: &apos;[name].[chunkhash:8].js&apos;, publicPath: &apos;/assets/&apos; + project + &apos;/&apos; }, devtool: &quot;eval&quot;, watch: false, profile: true, cache: true, module: { loaders: getLoaders(env) }, resolve: { alias: getAlias(env) }, plugins: getPlugins(env) }; } 其中关键的配置这儿简单介绍如下：context：上下文。entry：入口文件，是所有依赖关系的入口，webpack从这个入口开始静态解析，分析模块之间的依赖关系。output：打包输出的配置。devtools：SourceMap选项，便于开发模式下调试。watch：监听模式，增量更新，开发必备！profile：优化。cache：webpack构建的过程中会生成很多临时的文件，打开cache可以让这些临时的文件缓存起来，从而更快的构建。module.loaders：如前文介绍，loaders用来对文件做预处理。这样webpack就可以打包任何静态文件。resolve.alias：模块别名，这样可以更方便的引用模块。plugins：如前文介绍，webpack的一些内置功能均是以插件的形式提供。 六、webpack样式：内嵌css（不推荐）、独立的css、公共的css样式； 七、模块化机制特点：1、可以兼容多模块风格，无痛迁移老项目。2、一切皆模块，js/css/图片/字体都是模块。3、静态解析（确定依赖关系，输入输出的变量），按需打包，动态加载。（webpack最优秀的地方）；webpack提供的loaders可以对文件做预处理，从而实现了一切皆模块。 八、webpack对模块做了什么？（1）非模块化代码；（2）Runtime &amp; 模块；（3）AMD模块；（4）CommonJs； 九、代码分块：chunk–程序块；（1）CommonJs require.ensure(dependencies, callback)；（2）AMD require(dependencies, callback) 十、分块类型：（1）入口块 entry chunk；（2）普通块 normal chunk；（3）初始块 initial chunk；（4）多入口块； 十一、gulp&amp;webpack整合：1、目的：前端工程化；更好的管理前端代码； 2、怎么管理：gulp：处理html压缩/预处理/条件编译，图片压缩，精灵图自动合并等任务；webpack：管理模块化，构建js/css。 3、怎么整合：（1）webpack-stream方案[不推荐]；（2）webpack原生方案； 十二、怎么组织代码：gulp那一套、webpack原生方案； 十三、特别强调–webpack最优秀的地方：预处理；按需加载； webpack提供的require（）方法和require.ensure（）方法来实现，即AMD和commonJS规范； 十四、按需加载的时间戳：rake任务； ###十五、常用插件：1、解析压缩美化chunk：UglifyJsPlugin new webpack.optimize.UglifyJsPlugin([options])；2、分离css文件；ExtractTextPlugin var ExtractTextPlugin = require(“extract-text-webpack-plugin”);3、删除重复依赖；DedupePlugin new webpack.optimize.DedupePlugin()；4、跳过编译出错并记录；NoErrorsPlugin new webpack.NoErrorsPlugin()；5、提取公共模块；CommonsChunkPlugin new webpack.optimize.CommonsChunkPlugin(options)；]]></content>
    </entry>

    
  
  
</search>
