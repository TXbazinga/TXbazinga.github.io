<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[[转]AngularJS开发人员最常犯的10个错误]]></title>
      <url>%2F2017%2F03%2F17%2F%E8%BD%AC-AngularJS%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E6%9C%80%E5%B8%B8%E7%8A%AF%E7%9A%8410%E4%B8%AA%E9%94%99%E8%AF%AF%2F</url>
      <content type="text"><![CDATA[转自：[伯乐在线]http://blog.jobbole.com/78946/简介AngularJS是目前最为活跃的JavaScript框架之一，AngularJS的目标之一是简化开发过程，这使得AngularJS非常善于构建小型app原型，但AngularJS对于全功能的客户端应用程序同样强大，它结合了开发简便，特性广泛和出众的性能，使其被广泛使用。然而，大量使用也会产生诸多误区。以下这份列表摘取了常见的一些AngularJS的错误用法，尤其是在app开发过程中。 1. MVC目录结构AngularJS，直白地说，就是一个MVC框架。它的模型并没有像backbone.js框架那样定义的如此明确，但它的体系结构却恰如其分。当你工作于一个MVC框架时，普遍的做法是根据文件类型对其进行归类： 123456789101112131415templates/ _login.html _feed.htmlapp/ app.js controllers/ LoginController.js FeedController.js directives/ FeedEntryDirective.js services/ LoginService.js FeedService.js filters/ CapatalizeFilter.js 看起来，这似乎是一个显而易见的结构，更何况Rails也是这么干的。然而一旦app规模开始扩张，这种结构会导致你一次需要打开很多目录，无论你是使用sublime，Visual Studio或是Vim结合Nerd Tree，你都会投入很多时间在目录树中不断地滑上滑下。 与按照类型划分文件不同，取而代之的，我们可以按照特性划分文件： 12345678910111213app/ app.js Feed/ _feed.html FeedController.js FeedEntryDirective.js FeedService.js Login/ _login.html LoginController.js LoginService.js Shared/ CapatalizeFilter.js 这种目录结构使得我们能够更容易地找到与某个特性相关的所有文件，继而加快我们的开发进度。尽管将.html和.js文件置于一处可能存在争议，但节省下来的时间更有价值。 2. 模块将所有东西都一股脑放在主模块下是很常见的，对于小型app，刚开始并没有什么问题，然而很快你就会发现坑爹的事来了。 1234567var app = angular.module(&apos;app&apos;,[]);app.service(&apos;MyService&apos;, function()&#123; //service code&#125;);app.controller(&apos;MyCtrl&apos;, function($scope, MyService)&#123; //controller code&#125;); 在此之后，一个常见的策略是对相同类型的对象归类。 1234567891011var services = angular.module(&apos;services&apos;,[]);services.service(&apos;MyService&apos;, function()&#123; //service code&#125;); var controllers = angular.module(&apos;controllers&apos;,[&apos;services&apos;]);controllers.controller(&apos;MyCtrl&apos;, function($scope, MyService)&#123; //controller code&#125;); var app = angular.module(&apos;app&apos;,[&apos;controllers&apos;, &apos;services&apos;]); 这种方式和前面第一部分所谈到的目录结构差不多：不够好。根据相同的理念，可以按照特性归类，这会带来可扩展性。 12345678var sharedServicesModule = angular.module(&apos;sharedServices&apos;,[]);sharedServices.service(&apos;NetworkService&apos;, function($http)&#123;&#125;); var loginModule = angular.module(&apos;login&apos;,[&apos;sharedServices&apos;]);loginModule.service(&apos;loginService&apos;, function(NetworkService)&#123;&#125;);loginModule.controller(&apos;loginCtrl&apos;, function($scope, loginService)&#123;&#125;); var app = angular.module(&apos;app&apos;, [&apos;sharedServices&apos;, &apos;login&apos;]); 当我们开发一个大型应用程序时，可能并不是所有东西都包含在一个页面上。将同一类特性置于一个模块内，能使跨app间重用模块变得更容易。 3. 依赖注入依赖注入是AngularJS最好的模式之一，它使得测试更为简单，并且依赖任何指定对象都很明确。AngularJS的注入方式非常灵活，最简单的方式只需要将依赖的名字传入模块的function中即可： 1234567var app = angular.module(&apos;app&apos;,[]); app.controller(&apos;MainCtrl&apos;, function($scope, $timeout)&#123; $timeout(function()&#123; console.log($scope); &#125;, 1000);&#125;); 这里，很明显，MainCtrl依赖$scope和$timeout。 直到你准备将其部署到生产环境并希望精简代码时，一切都很美好。如果使用UglifyJS，之前的例子会变成下面这样： 12var app=angular.module(&quot;app&quot;,[]);app.controller(&quot;MainCtrl&quot;,function(e,t)&#123;t(function()&#123;console.log(e)&#125;,1e3)&#125;) 现在AngularJS怎么知道MainCtrl依赖谁？AngularJS提供了一种非常简单的解决方法，即将依赖作为一个数组传入，数组的最后一个元素是一个函数，所有的依赖项作为它的参数。 12345app.controller(&apos;MainCtrl&apos;, [&apos;$scope&apos;, &apos;$timeout&apos;, function($scope, $timeout)&#123; $timeout(function()&#123; console.log($scope); &#125;, 1000);&#125;]); 这样做能够精简代码，并且AngularJS知道如何解释这些明确的依赖： 1app.controller(&quot;MainCtrl&quot;,[&quot;$scope&quot;,&quot;$timeout&quot;,function(e,t)&#123;t(function()&#123;console.log(e)&#125;,1e3)&#125;]) 3.1 全局依赖在编写AngularJS程序时，时常会出现这种情况：某个对象有一个依赖，而这个对象又将其自身绑定在全局scope上，这意味着在任何AngularJS代码中这个依赖都是可用的，但这却破坏了依赖注入模型，并会导致一些问题，尤其体现在测试过程中。 使用AngularJS可以很容易的将这些全局依赖封装进模块中，所以它们可以像AngularJS标准模块那样被注入进去。 Underscrore.js是一个很赞的库，它可以以函数式的风格简化Javascript代码，通过以下方式，你可以将其转化为一个模块： 12345678910111213var underscore = angular.module(&apos;underscore&apos;, []);underscore.factory(&apos;_&apos;, function() &#123; return window._; //Underscore must already be loaded on the page&#125;);var app = angular.module(&apos;app&apos;, [&apos;underscore&apos;]);app.controller(&apos;MainCtrl&apos;, [&apos;$scope&apos;, &apos;_&apos;, function($scope, _) &#123; init = function() &#123; _.keys($scope); &#125; init();&#125;]); 这样的做法允许应用程序继续以AngularJS依赖注入的风格进行开发，同时在测试阶段也能将underscore交换出去。 这可能看上去十分琐碎，没什么必要，但如果你的代码中正在使用use strict（而且必须使用），那这就是必要的了。 4. 控制器膨胀控制器是AngularJS的肉和土豆，一不小心就会将过多的逻辑加入其中，尤其是刚开始的时候。控制器永远都不应该去操作DOM，或是持有DOM选择器，那是我们需要使用指令和ng-model的地方。同样的，业务逻辑应该存在于服务中，而非控制器。 数据也应该存储在服务中，除非它们已经被绑定在$scope上了。服务本身是单例的，在应用程序的整个生命周期都存在，然而控制器在应用程序的各状态间是瞬态的。如果数据被保存在控制器中，当它被再次实例化时就需要重新从某处获取数据。即使将数据存储于localStorage中，检索的速度也要比Javascript变量慢一个数量级。 AngularJS在遵循单一职责原则（SRP）时运行良好，如果控制器是视图和模型间的协调者，那么它所包含的逻辑就应该尽量少，这同样会给测试带来便利。 5. Service vs Factory几乎每一个AngularJS开发人员在初学时都会被这些名词所困扰，这真的不太应该，因为它们就是针对几乎相同事物的语法糖而已！ 以下是它们在AngularJS源代码中的定义： 123456789function factory(name, factoryFn) &#123; return provider(name, &#123; $get: factoryFn &#125;); &#125;function service(name, constructor) &#123; return factory(name, [&apos;$injector&apos;, function($injector) &#123; return $injector.instantiate(constructor); &#125;]);&#125; 从源代码中你可以看到，service仅仅是调用了factory函数，而后者又调用了provider函数。事实上，AngularJS也为一些值、常量和装饰提供额外的provider封装，而这些并没有导致类似的困惑，它们的文档都非常清晰。 由于service仅仅是调用了factory函数，这有什么区别呢？线索在$injector.instantiate：在这个函数中，$injector在service的构造函数中创建了一个新的实例。 以下是一个例子，展示了一个service和一个factory如何完成相同的事情： 123456789101112131415var app = angular.module(&apos;app&apos;,[]);app.service(&apos;helloWorldService&apos;, function()&#123; this.hello = function() &#123; return &quot;Hello World&quot;; &#125;;&#125;);app.factory(&apos;helloWorldFactory&apos;, function()&#123; return &#123; hello: function() &#123; return &quot;Hello World&quot;; &#125; &#125;&#125;); 当helloWorldService或helloWorldFactory被注入到控制器中，它们都有一个hello方法，返回”hello world”。service的构造函数在声明时被实例化了一次，同时factory对象在每一次被注入时传递，但是仍然只有一个factory实例。所有的providers都是单例。 既然能做相同的事，为什么需要两种不同的风格呢？相对于service，factory提供了更多的灵活性，因为它可以返回函数，这些函数之后可以被新建出来。这迎合了面向对象编程中工厂模式的概念，工厂可以是一个能够创建其他对象的对象。 123456789app.factory(&apos;helloFactory&apos;, function() &#123; return function(name) &#123; this.name = name; this.hello = function() &#123; return &quot;Hello &quot; + this.name; &#125;; &#125;;&#125;); 这里是一个控制器示例，使用了service和两个factory，helloFactory返回了一个函数，当新建对象时会设置name的值。 123456789app.controller(&apos;helloCtrl&apos;, function($scope, helloWorldService, helloWorldFactory, helloFactory) &#123; init = function() &#123; helloWorldService.hello(); //&apos;Hello World&apos; helloWorldFactory.hello(); //&apos;Hello World&apos; new helloFactory(&apos;Readers&apos;).hello() //&apos;Hello Readers&apos; &#125; init();&#125;); 在初学时，最好只使用service。 Factory在设计一个包含很多私有方法的类时也很有用： 1234567891011app.factory(&apos;privateFactory&apos;, function()&#123; var privateFunc = function(name) &#123; return name.split(&quot;&quot;).reverse().join(&quot;&quot;); //reverses the name &#125;; return &#123; hello: function(name)&#123; return &quot;Hello &quot; + privateFunc(name); &#125; &#125;;&#125;); 通过这个例子，我们可以让privateFactory的公有API无法访问到privateFunc方法，这种模式在service中是可以做到的，但在factory中更容易。 6. 没有使用BatarangBatarang是一个出色的Chrome插件，用来开发和测试AngularJS app。 Batarang提供了浏览模型的能力，这使得我们有能力观察AngularJS内部是如何确定绑定到作用域上的模型的，这在处理指令以及隔离一定范围观察绑定值时非常有用。 Batarang也提供了一个依赖图， 如果我们正在接触一个未经测试的代码库，这个依赖图就很有用，它能决定哪些服务应该被重点关照。 最后，Batarang提供了性能分析。Angular能做到开包即用，性能良好，然而对于一个充满了自定义指令和复杂逻辑的应用而言，有时候就不那么流畅了。使用Batarang性能工具，能够直接观察到在一个digest周期中哪个函数运行了最长时间。性能工具也能展示一棵完整的watch树，在我们拥有很多watcher时，这很有用。 7. 过多的watcher在上一点中我们提到，AngularJS能做到开包即用，性能良好。由于需要在一个digest周期中完成脏数据检查，一旦watcher的数量增长到大约2000时，这个周期就会产生显著的性能问题。（2000这个数字不能说一定会造成性能大幅下降，但这是一个不错的经验数值。在AngularJS 1.3 release版本中，已经有一些允许严格控制digest周期的改动了，Aaron Gray有一篇很好的文章对此进行解释。） 以下这个“立即执行的函数表达式(IIFE)”会打印出当前页面上所有的watcher的个数，你可以简单的将其粘贴到控制台中，观察结果。这段IIFE来源于Jared在StackOverflow上的回答： 1234567891011121314151617181920(function () &#123; var root = $(document.getElementsByTagName(&apos;body&apos;)); var watchers = []; var f = function (element) &#123; if (element.data().hasOwnProperty(&apos;$scope&apos;)) &#123; angular.forEach(element.data().$scope.$$watchers, function (watcher) &#123; watchers.push(watcher); &#125;); &#125; angular.forEach(element.children(), function (childElement) &#123; f($(childElement)); &#125;); &#125;; f(root); console.log(watchers.length);&#125;)(); 通过这个方式得到watcher的数量，结合Batarang性能板块中的watch树，应该可以看到哪里存在重复代码，或着哪里存在不变数据同时拥有watch。 当存在不变数据，而你又想用AngularJS将其模版化，可以考虑使用bindonce。Bindonce是一个简单的指令，允许你使用AngularJS中的模版，但它并不会加入watch，这就保证了watch数量不会增长。 8. 限定$scope的范围Javascript基于原型的继承与面向对象中基于类的继承有着微妙的区别，这通常不是什么问题，但这个微妙之处在使用$scope时就会表现出来。在AngularJS中，每个$scope都会继承父$scope，最高层称之为$rootScope。（$scope与传统指令有些不同，它们有一定的作用范围i，且只继承显式声明的属性。） 由于原型继承的特点，在父类和子类间共享数据不太重要，不过如果不小心的话，也很容易误用了一个父$scope的属性。 比如说，我们需要在一个导航栏上显示一个用户名，这个用户名是在登录表单中输入的，下面这种尝试应该是能工作的： 1234567&lt;div ng-controller=&quot;navCtrl&quot;&gt; &lt;span&gt;&#123;&#123;user&#125;&#125;&lt;/span&gt; &lt;div ng-controller=&quot;loginCtrl&quot;&gt; &lt;span&gt;&#123;&#123;user&#125;&#125;&lt;/span&gt; &lt;input ng-model=&quot;user&quot;&gt;&lt;/input&gt; &lt;/div&gt;&lt;/div&gt; 那么问题来了……：在text input中设置了user的ng-model，当用户在其中输入内容时，哪个模版会被更新？navCtrl还是loginCtrl，还是都会？ 如果你选择了loginCtrl，那么你可能已经理解了原型继承是如何工作的了。 当你检索字面值时，原型链并不起作用。如果navCtrl也同时被更新的话，检索原型链是必须的；但如果值是一个对象，这就会发生。（记住，在Javascript中，函数、数组和对象都是对象） 所以为了获得预期的行为，需要在navCtrl中创建一个对象，它可以被loginCtrl引用。 1234567&lt;div ng-controller=&quot;navCtrl&quot;&gt; &lt;span&gt;&#123;&#123;user.name&#125;&#125;&lt;/span&gt; &lt;div ng-controller=&quot;loginCtrl&quot;&gt; &lt;span&gt;&#123;&#123;user.name&#125;&#125;&lt;/span&gt; &lt;input ng-model=&quot;user.name&quot;&gt;&lt;/input&gt; &lt;/div&gt;&lt;/div&gt; 现在，由于user是一个对象，原型链就会起作用，navCtrl模版和$scope和loginCtrl都会被更新。 这看上去是一个很做作的例子，但是当你使用某些指令去创建子$scope，如ngRepeat时，这个问题很容易就会产生。 9. 手工测试由于TDD可能不是每个开发人员都喜欢的开发方式，因此当开发人员检查代码是否工作或是否影响了其它东西时，他们会做手工测试。 不去测试AngularJS app，这是没有道理的。AngularJS的设计使得它从头到底都是可测试的，依赖注入和ngMock模块就是明证。AngularJS核心团队已经开发了众多能够使测试更上一层楼的工具。 9.1 Protractor单元测试是一个测试工作的基础，但考虑到app的日益复杂，集成测试更贴近实际情况。幸运的是，AngularJS的核心团队已经提供了必要的工具。 我们已经建立了Protractor，一个端到端的测试器用以模拟用户交互，这能够帮助你验证你的AngularJS程序的健康状况。 Protractor使用Jasmine测试框架定义测试，Protractor针对不同的页面交互行为有一个非常健壮的API。 我们还有一些其他的端到端测试工具，但是Protractor的优势是它能够理解如何与AngularJS代码协同工作，尤其是在$digest周期中。 9.2 Karma一旦我们用Protractor完成了集成测试的编写工作，接下去就是执行测试了。等待测试执行，尤其是集成测试，对每个开发人员都是一种淡淡的忧伤。AngularJS的核心团队也感到极为蛋疼，于是他们开发了Karma。 Karma是一个测试器，它有助于关闭反馈回路。Karma之所以能够做到这点，是因为它在指定文件被改变时就运行测试。Karma同时也会在多个浏览器上运行测试，不同的设备也可以指向Karma服务器，这样就能够更好地覆盖真实世界的应用场景。 10. 使用jQueryjQuery是一个酷炫的库，它有标准化的跨平台开发，几乎已经成为了现代化Web开发的必需品。不过尽管JQuery如此多的优秀特性，它的理念和AngularJS并不一致。 AngularJS是一个用来建立app的框架，而JQuery则是一个简化“HTML文档操作、事件处理、动画和Ajax”的库。这是两者最基本的区别，AngularJS致力于程序的体系结构，与HTML页面无关。 为了更好的理解如何建立一个AngularJS程序，请停止使用jQuery。JQuery使开发人员以现存的HTML标准思考问题，但正如文档里所说的，“AngularJS能够让你在应用程序中扩张HTML这个词汇”。 DOM操作应该只在指令中完成，但这并不意味着他们只能用JQuery封装。在你使用JQuery之前，你应该总是去想一下这个功能是不是AngularJS已经提供了。当指令互相依赖时能够创建强大的工具，这确实很强大。 但一个非常棒的JQuery是必需品时，这一天可能会到来，但在一开始就引入它，是一个常见的错误。 结论AngularJS是一卓越的框架，在社区的帮助下始终在进步。虽说AngularJS仍然是一个不断发展的概念，但我希望人们能够遵循以上谈到的这些约定，避免开发AngularJS应用所遇到的那些问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React生命周期]]></title>
      <url>%2F2017%2F03%2F15%2FReact%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
      <content type="text"><![CDATA[React组件的生命周期创建期(五个阶段)1.getDefaultProps(获取默认属性) 作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享。 2.getInitialState (获取默认状态) 作用于组件的实例，在实例创建时调用一次，用于初始化每个实例的state，此时可以访问this.props。 3.componentWillMount (组件将要构建) 在完成首次渲染之前调用，此时仍可以修改组件的state。4.render (组件渲染输出虚拟dom) 必选的方法，创建虚拟DOM，该方法具有特殊的规则: 只能通过this.props和this.state访问数据 可以返回null、false或任何React组件 只能出现一个顶级组件（不能返回数组） 不能改变组件的状态 * 不能修改DOM的输出 5.componentDidMount(组件渲染完成) 真实的DOM被渲染出来后调用，在该方法中可通过this.getDOMNode()(也可以ReactDOM.findDOMNode(this))访问到真实的DOM元素。此时已可以使用其他类库来操作这个DOM。（在服务端中，该方法不会被调用） 存在期 (五个阶段)1.componentWillReceiveProps(接受新的属性) 组件接收到新的props时调用，并将其作为参数nextProps使用，此时可以更改组件props及state。 componentWillReceiveProps: function(nextProps) { if (nextProps.bool) { this.setState({ bool: true }); } } 2.shouldComponentUpdate(组建是否应该更新) **必须有返回值(return false/true) 第一个参数是新属性 第二个参数是新状态 组件是否应当渲染新的props或state，返回false表示跳过后续的生命周期方法，通常不需要使用以避免出现bug。在出现应用的瓶颈时，可通过该方法进行适当的优化。 3.componentWillUpdate (组件将要被更新) 第一个参数是新属性第二个参数是新状态 接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state。 4.render(组件更新输出dom) 没有参数 这个阶段访问的都是旧的虚拟dom 只有之后的一个阶段访问的才是新的虚拟dom 5.componentDidUpdate(组件更新完成) 完成渲染新的props或者state后调用，此时可以访问到新的DOM元素。 销毁期 componentWillUnmount组件被移除之前被调用，可以用于做一些清理工作，在componentDidMount方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack15个知识点!]]></title>
      <url>%2F2017%2F03%2F13%2Fwebpack%2F</url>
      <content type="text"><![CDATA[一、模块化系统演进：1、传统：&lt;script src=“module.js”&gt;标签； 2、commonJS：协同require（）同步加载，再通过exports或module.exports来导出需要暴露的接口；不能加载多个模块；不适合浏览器加载。 3、AMD:异步require，通过接口define（） 异步加载；可并行加载多个模块；适合浏览器。 4、CMD:类似AMD； 5、UMD:是模块跨平台解决方案； 6、ES6:尽量静态化；编译时就能确定模块的依赖关系及输入输出变量；CommonJs和AMD都只能在运行时确定这些东西。优点：静态分析，提前编译；面向未来的标准；缺点：1、浏览器原生兼容性差，所以一般都编译成ES5。2、目前可以拿来即用的模块少，生态差。 7、期望的模块：可以兼容多种模块风格，尽量可以利用已有的代码，不仅仅只是 JavaScript 模块化，还有 CSS、图片、字体等资源也需要模块化。 二、gulp&amp;webpack区别：gulp是基于流的构建工具：all in one的打包模式，输出一个js文件和一个css文件，优点是减少http请求，万金油方案。webpack是模块化管理工具，使用webpack可以对模块进行压缩、预处理、打包、按需加载等。 三、webpack概念：webpack是模块化管理工具，使用webpack可以对模块进行压缩、预处理、按需打包、按需加载等。 四、webpack9个特征：（1）插件化：webpack本身非常灵活，提供了丰富的插件接口。基于这些接口，webpack开发了很多插件作为内置功能。（2）速度快：webpack使用异步IO以及多级缓存机制。所以webpack的速度是很快的，尤其是增量更新。（3）丰富的Loaders：loaders用来对文件做预处理。这样webpack就可以打包任何静态文件。（4）高适配性：webpack同时支持AMD/CommonJs/ES6模块方案。webpack会静态解析你的代码，自动帮你管理他们的依赖关系。此外，webpack对第三方库的兼容性很好。（5）代码拆分：webpack可以将你的代码分片，从而实现按需打包。这种机制可以保证页面只加载需要的JS代码，减少首次请求的时间。（6）优化：webpack提供了很多优化机制来减少打包输出的文件大小，不仅如此，它还提供了hash机制，来解决浏览器缓存问题。（7）开发模式友好：webpack为开发模式也提供了很多辅助功能。比如SourceMap、热更新等。（8）使用场景多：webpack不仅适用于web应用场景，也适用于Webworkers、Node.js场景。（9）优点：webpack并不强制你使用某种模块化方案，而是通过兼容所有模块化方案让你无痛接入项目，当然这也是webpack牛逼的地方。有了webpack，你可以随意选择你喜欢的模块化方案，至于怎么处理模块之间的依赖关系及如何按需打包，放轻松，webpack会帮你处理好的。 五、webpack配置及参数解析：1、两份配置文件webpack.config.production.js/webpack.config.development.js，然后不同场景下，使用不同的配置文件。2、通过module.exports返回函数，该函数能接受参数。相对来说，第一种更简单，但是重复配置多；第二种更灵活，推荐第二种方式。 webpack 如何最佳配置？webpack官方提供的配置方法是通过module.exports返回一个json，但是这种场景不灵活，不能适配多种场景。比如要解决：production模式和development模式，webpack的配置是有差异的，大致有两种思路。1、两份配置文件webpack.config.production.js/webpack.config.development.js，然后不同场景下，使用不同的配置文件。2、通过module.exports返回函数，该函数能接受参数。相对来说，第一种更简单，但是重复配置多；第二种更灵活，推荐第二种方式。那么，按返回函数的方式的配置代码架子如下： module.exports = function(env) { return { context: config.context, entry: config.src, output: { path: path.join(config.jsDest, project), filename: &apos;[name].js&apos;, chunkFilename: &apos;[name].[chunkhash:8].js&apos;, publicPath: &apos;/assets/&apos; + project + &apos;/&apos; }, devtool: &quot;eval&quot;, watch: false, profile: true, cache: true, module: { loaders: getLoaders(env) }, resolve: { alias: getAlias(env) }, plugins: getPlugins(env) }; } 其中关键的配置这儿简单介绍如下：context：上下文。entry：入口文件，是所有依赖关系的入口，webpack从这个入口开始静态解析，分析模块之间的依赖关系。output：打包输出的配置。devtools：SourceMap选项，便于开发模式下调试。watch：监听模式，增量更新，开发必备！profile：优化。cache：webpack构建的过程中会生成很多临时的文件，打开cache可以让这些临时的文件缓存起来，从而更快的构建。module.loaders：如前文介绍，loaders用来对文件做预处理。这样webpack就可以打包任何静态文件。resolve.alias：模块别名，这样可以更方便的引用模块。plugins：如前文介绍，webpack的一些内置功能均是以插件的形式提供。 六、webpack样式：内嵌css（不推荐）、独立的css、公共的css样式； 七、模块化机制特点：1、可以兼容多模块风格，无痛迁移老项目。2、一切皆模块，js/css/图片/字体都是模块。3、静态解析（确定依赖关系，输入输出的变量），按需打包，动态加载。（webpack最优秀的地方）；webpack提供的loaders可以对文件做预处理，从而实现了一切皆模块。 八、webpack对模块做了什么？（1）非模块化代码；（2）Runtime &amp; 模块；（3）AMD模块；（4）CommonJs； 九、代码分块：chunk–程序块；（1）CommonJs require.ensure(dependencies, callback)；（2）AMD require(dependencies, callback) 十、分块类型：（1）入口块 entry chunk；（2）普通块 normal chunk；（3）初始块 initial chunk；（4）多入口块； 十一、gulp&amp;webpack整合：1、目的：前端工程化；更好的管理前端代码； 2、怎么管理：gulp：处理html压缩/预处理/条件编译，图片压缩，精灵图自动合并等任务；webpack：管理模块化，构建js/css。 3、怎么整合：（1）webpack-stream方案[不推荐]；（2）webpack原生方案； 十二、怎么组织代码：gulp那一套、webpack原生方案； 十三、特别强调–webpack最优秀的地方：预处理；按需加载； webpack提供的require（）方法和require.ensure（）方法来实现，即AMD和commonJS规范； 十四、按需加载的时间戳：rake任务； ###十五、常用插件：1、解析压缩美化chunk：UglifyJsPlugin new webpack.optimize.UglifyJsPlugin([options])；2、分离css文件；ExtractTextPlugin var ExtractTextPlugin = require(“extract-text-webpack-plugin”);3、删除重复依赖；DedupePlugin new webpack.optimize.DedupePlugin()；4、跳过编译出错并记录；NoErrorsPlugin new webpack.NoErrorsPlugin()；5、提取公共模块；CommonsChunkPlugin new webpack.optimize.CommonsChunkPlugin(options)；]]></content>
    </entry>

    
  
  
</search>
